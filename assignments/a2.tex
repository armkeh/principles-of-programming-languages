% Created 2020-11-11 Wed 11:27
% Intended LaTeX compiler: lualatex
\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{tabularx}
\usepackage{etoolbox}
\makeatletter
\def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
\AtBeginEnvironment{minted}{\dontdofcolorbox}
\makeatother
\usepackage[newfloat]{minted}
\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\usepackage{unicode-math}
\usepackage{unicode}
\author{Mark Armstrong}
\date{October 30th, 2020}
\title{Computer Science 3MI3 – 2020 assignment 2\\\medskip
\large Typing a λ-calculus}
\hypersetup{
   pdfauthor={Mark Armstrong},
   pdftitle={Computer Science 3MI3 – 2020 assignment 2},
   pdfkeywords={},
   pdfsubject={Type checking and erasing on a simply-typed λ-calculus.},
   pdfcreator={Emacs 27.0.91 (Org mode 9.4)},
   pdflang={English},
   colorlinks,
   linkcolor=blue,
   citecolor=blue,
   urlcolor=blue
   }
\begin{document}

\maketitle
\tableofcontents


\section*{Introduction}
\label{sec:org007cd00}
This assignment asks you to construct representation
of a simply-typed λ-calculus, construct a typechecker for that
λ-calculus, and finally to implement \emph{type-erasure} and a
simple translator to simplify terms to untyped λ-calculus terms.

\section*{Updates and file history}
\label{sec:orgbfc0b2d}
\subsection*{November 10th}
\label{sec:org99bc94b}
\begin{itemize}
\item The testing section has been completed.
\item The subclasses of the \texttt{ULTerm} class in Ruby have had
a \texttt{==} method added to them. This method
is necessary for the testing of Part 3,
and you will need to copy its definitions or
re-download the \href{./src/a2\_ulterm.rb}{\texttt{a2\_ulterm.rb}} file.
\item Notes about the means of implementing type checking have been added.
\item The names of the types for natural numbers and booleans
in the \emph{ST} language have been shortened, to \texttt{nat} and \texttt{bool}.
\begin{itemize}
\item Classes to represent these types in both Scala and Ruby
have also been provided.
\end{itemize}
\end{itemize}

\subsection*{November 6th}
\label{sec:orgb6d13f8}
\begin{itemize}
\item The typing rules for the \emph{ST} language were added
in part 0.1.
\end{itemize}

\subsection*{November 5th}
\label{sec:org32368c0}
\begin{itemize}
\item A typo in a variable name in the Ruby implementation
of \texttt{ULTerm} was corrected.
\item The provided Scala code for the \texttt{ULTerm} type was modified
slightly to include better \texttt{toString} methods.
\item Example code showing how to construct \texttt{ULTerm} terms
and perform substitutions with them was added to part 0.2.
\end{itemize}

\subsection*{November 1st}
\label{sec:org855b7ac}
\begin{itemize}
\item Part 4 was made bonus
\begin{itemize}
\item and the task of translating from \texttt{ULTerm}'s to \texttt{STTerm}'s was
made part of the question.
\end{itemize}
\end{itemize}

\subsection*{October 30th}
\label{sec:orgb664686}
\begin{itemize}
\item Initial version posted.
\begin{itemize}
\item Testing not posted yet.
\end{itemize}
\end{itemize}

\section*{Boilerplate}
\label{sec:org366abd3}
\subsection*{Documentation}
\label{sec:orgc77bf21}
In addition to the code for the assignments,
you are required to submit (relatively light) documentation,
along the lines of that found in
\href{https://armkeh.github.io/principles-of-programming-languages/\#outline-container-Lecture-literate-programs}{the literate programs}
from lectures and tutorials.
\begin{itemize}
\item Those occasionally include a lot of writing when introducing concepts;
you do not have to introduce concepts, so your documentation
should be similar to the \emph{end} of those documents,
where only the purpose and implementation details
of types, functions, etc., are discussed.
\end{itemize}

This documentation is not assigned its own marks;
rather, 20\% of the marks of each part of the assignment
will be for the documentation.

This documentation \textbf{must be} in the literate style,
with (nicely typeset) English paragraphs alongside code snippets;
comments in your source code do not count.
The basic requirement is
\begin{itemize}
\item the English paragraphs must use non-fixed width font, whereas
\item the code snippets must use fixed width font.
\item For example, see these lecture notes on Prolog:
\begin{itemize}
\item \url{https://courses.cs.washington.edu/courses/cse341/98sp/logic/prolog.html}
\end{itemize}
\end{itemize}
But you are encouraged to strive for nicer than just
“the basic requirement”.
(the ability to write decent looking documentation is an asset!

You are free to present your documentation in any of these formats:
\begin{itemize}
\item an HTML file,
\begin{itemize}
\item (named \texttt{README.html})
\end{itemize}
\item a PDF (for instance, by writing it in \LaTeX{} using
the \texttt{listings} or \texttt{minted} package for your code blocks),
\begin{itemize}
\item (named \texttt{README.pdf}), or
\end{itemize}
\item rendering on GitLab (for instance, by writing it in markdown or Org)
\begin{itemize}
\item (named \texttt{README.md} or \texttt{README.org}.)
\end{itemize}
\end{itemize}
If you wish to use another format, contact Mark to discuss it.

Not all of your code needs to be shown;
only portions which are of interest are needed.
Feel free to omit some “repetitive” portions.
(For instance, if there are several cases in a definition
which look almost identical, only one or two need to be shown.)

\subsection*{Submission procedures}
\label{sec:org0b2f068}
The same guidelines as for homework
(which can be seen in any of the homework files)
apply to assignments, except for the differences below.

\subsubsection*{Assignment naming requirements}
\label{sec:org94051f7}

Place all files for the assignment
inside a folder titled \texttt{an}, where \texttt{n} is the number of the assignment.
So, for assignment 1, use the folder \texttt{a1}, for assignment 2 the folder \texttt{a2}, etc.
Ensure you do not capitalise the \texttt{a}.

Each part of the assignments will direct you on where to
save your code for that part. Follow those instructions!

\begin{center}
\textbf{If the language supports multiple different file extensions,}
\textbf{you must still follow the extension conventions noted in the assignment.}
\end{center}

\begin{center}
\textbf{Incorrect naming of files may result in up to a 5\% deduction in your grade.}
\end{center}
This is slightly decreased from the 10\% for homeworks.

\subsection*{Proper conduct for coursework}
\label{sec:orgc48360b}
Refer to the homework code of conduct available in any of the homework files.
The same guidelines apply to assignments.

\section*{Part 0.1 – Description of the λ-calculus, \emph{ST}                 [0 marks]}
\label{sec:org77576c1}
The λ-calculus you are to work with during this assignment
we call \emph{ST}, standing for \emph{simply typed}.
It adds to the pure untyped λ-calculus \emph{UL}
terms \texttt{zero}, \texttt{suc}, \texttt{iszero}, \texttt{tt}, \texttt{ff}, and \texttt{test}, with the following syntax.
\begin{minted}[breaklines=true]{text}
⟨typedterm⟩ ∷= var
             | ⟨typedterm⟩ ⟨typedterm⟩
             | λ var : ⟨type⟩ → ⟨typedterm⟩
             | zero
             | suc ⟨typedterm⟩
             | iszero ⟨typedterm⟩
             | true
             | false
             | test ⟨typedterm⟩ ⟨typedterm⟩ ⟨typedterm⟩

⟨type⟩ ∷= ⟨type⟩ → ⟨type⟩
        | nat
        | bool
\end{minted}

We also introduce the following \emph{typing rules} for these typed λ-terms.
The rules make use of a \emph{typing context} or \emph{type environment} Γ.

The first rule says that variables have the type they are given
by the environment Γ (assuming they are given a type at all.)
\begin{minted}[breaklines=true]{text}
 x : A ∈ Γ
–––––––––––– T-Var
 Γ ⊢ x : A
\end{minted}

The second rule says that if by adding “\texttt{x} has type \texttt{A}” to the environment,
we can conclude that \texttt{t₂} has type \texttt{B}, then
the term \texttt{λ x : A → t₂} has type \texttt{A → B}.
(Notice that this rule is the only time we add to the environment.)
\begin{minted}[breaklines=true]{text}
 Γ,(x : A) ⊢ t : B
––––––––––––––––––––––––––––––– T-Abs
 Γ ⊢ (λ x : A → t) : A → B
\end{minted}

The third rule says that if \texttt{t₁} has the function type \texttt{A → B},
and \texttt{t₂} has the type \texttt{A}, then \texttt{t₂} applied to \texttt{t₁} has type \texttt{B}.
\begin{minted}[breaklines=true]{text}
 Γ ⊢ t₁ : A → B    Γ ⊢ t₂ : A
––––––––––––––––––––––––––––––––– T-App
        Γ ⊢ t₁ t₂ : B
\end{minted}

The remaining rules give the typings for the constants and
function terms added to this language.
\begin{minted}[breaklines=true]{text}
                                   Γ ⊢ t : nat
––––––––––––––––––– T-zero      –––––––––––––––––––– T-suc
 Γ ⊢ zero : nat                  Γ ⊢ suc t : nat
                            
                            
                         
––––––––––––––––––– T-true    –––––––––––––––––––– T-false
 Γ ⊢ true : bool               Γ ⊢ false : bool


    Γ ⊢ t : nat
–––––––––––––––––––––––– T-iszero
 Γ ⊢ iszero t : bool 


 Γ ⊢ b : bool    Γ ⊢ t₁ : A    Γ ⊢ t₂ : A
––––––––––––––––––––––––––––––––––––––––––––– T-test
            Γ ⊢ test b t₁ t₂ : A
\end{minted}

\section*{Part 0.2 – A representation of the untyped λ-calculus, \emph{UL}    [0 marks]}
\label{sec:orgdf18a1f}
\subsection*{Nameless representation of terms}
\label{sec:org93a03e3}
We use \emph{de Bruijn indices} in place of named variables.
The index “points” to a binder, or to a free variable.
\begin{itemize}
\item \texttt{0} points to the first enclosing variable binder,
or the first free variable if there are no enclosing binders.
\item \texttt{1} points to the second enclosing variable binder,
or the \texttt{2-n}'th free variable if there are only \texttt{n} enclosing binders, \texttt{n ≤ 1}.
\item \texttt{2} points to the third enclosing variable binder,
or the \texttt{3-n}'th free variable if there are only \texttt{n} enclosing binders, \texttt{n ≤ 2}.
\item …
\item \texttt{i} points to the \texttt{i}'th enclosing variable binder,
or the \texttt{(i+1)-n}'th free variable if there are only \texttt{n} enclosing binders, \texttt{n ≤ i}.
\item …
\end{itemize}

This representation avoids any need for renaming variables
during substitution.

It does make terms less human readable;
we can correct for this by writing a \emph{pretty printer} for λ-terms
(which will be the focus of a homework.)

\subsection*{Scala implementation}
\label{sec:org61c0bb5}
Pure untyped λ-terms can only be variables, abstractions or applications.
(Updated November 5th) We include as parts of the case classes
overrides of the \texttt{toString} method, which improve the appearance
of these terms when they are converted to strings.
\begin{minted}[breaklines=true]{scala}
sealed trait ULTerm
case class ULVar(index: Int) extends ULTerm {
  override def toString() = index.toString()
}
case class ULAbs(t: ULTerm) extends ULTerm {
  override def toString() = "lambda . " + t.toString()
}
case class ULApp(t1: ULTerm, t2: ULTerm) extends ULTerm {
  override def toString() = "(" + t1.toString() + ") (" + t2.toString() + ")"
}
\end{minted}

The use of de Bruijn indices necessitates a method to
“shift” the indices of free variables up or down;
for instance, when applying a term to an abstraction,
we must shift them up to avoid capturing what should be free variables
in a variable binder.

Shifting is done by walking through the term,
incrementing the variable indices by the shift amount
if their index is greater than the number of enclosing binders.
\begin{minted}[breaklines=true]{scala}
// Shift the numbering of unbound variables
def shift(shiftAmount: Int, t: ULTerm): ULTerm = {
  // Walk through the term and shift all variables with index
  // greater than or equal to c, which is maintained to be
  // the number of variable binders (abstractions) outside the current subterm.
  def walk(currentBinders: Int, t: ULTerm): ULTerm = t match {
    // Check if x is a free variable; that is,
    // if the number x is greater than or equal to
    // the number of variable binders encountered outside this subterm.
    case ULVar(x) if (x >= currentBinders) => ULVar(x+shiftAmount)
    case ULVar(x) => ULVar(x)

    case ULAbs(t) =>
      // We now have one more variable binder outside the subterm.
      // Increment currentBinders and walk into the subterm.
      ULAbs(walk(currentBinders+1, t))

    case ULApp(t1,t2) =>
      // No new variable binders. Just walk into the subterms.
      ULApp(walk(currentBinders,t1),walk(currentBinders,t2))
  }

  // Walk the term and perform the shift of free variables.
  // We begin with 0 variable binders outside.
  walk(0, t)
}
\end{minted}

Substitution is similarly defined by “walking” through the term,
but here, when we find variables, we choose whether to “replace them”
by the term being subbed in or not.
We have to adjust the variable being substituted and the
free variables in the term being subbed in according to
the number of variable binders we enter.
\begin{minted}[breaklines=true]{scala}
// In our usual syntax, we would write substitution as `t[x := r]`.
// Here we write `substitute(t,x,r)`.
def substitute(t: ULTerm, x: Int, r: ULTerm): ULTerm = {
  // We want to substitute for the free variable with number x.
  // Inside a variable binder (abstraction),
  // the index of all free variables is shifted up by 1.
  // So we must keep track of the number of binders outside the current subterm.
  def walk(currentBinders: Int, t: ULTerm): ULTerm = t match {
    case ULVar(y) if y == x + currentBinders =>
      // y is the xth free variable. Substitute for it,
      // making sure to shift the free variables in r
      // to account for the number of variable binders outside this subterm.
      shift(currentBinders,r)
    
    case ULVar(y) =>
      // Otherwise, y is not the xth free variable;
      // leave it as is.
      ULVar(y)
    
    case ULAbs(t) =>
      // We now have one more variable binder outside the subterm.
      // Increment currentBinders and walk into the subterm.
      ULAbs(walk(currentBinders+1,t))

    case ULApp(t1,t2) =>
      // No new variable binders. Just walk into the subterms.
      ULApp(walk(currentBinders,t1),walk(currentBinders,t2))
  }

  // Walk the term, performing the substitution.
  // We begin with 0 variable binders outside.
  walk(0,t)
}
\end{minted}

We need to check if terms are values for call-by-value semantics.
\begin{minted}[breaklines=true]{scala}
// We need to know if a term is a value during reduction
// when using call-by-value semantics.
def isValue(t: ULTerm): Boolean = t match {
  case ULAbs(_) => true
  case _ => false
}
\end{minted}

Those semantics are given by a reduction function,
which reduces terms by one step, and then an evaluation function,
which keeps reducing until we get stuck (\emph{if} we get stuck;
we might have an infinite reduction sequence.)
\begin{minted}[breaklines=true]{scala}
// Call-by-value reduction function.
// Performs one step of evaluation, if possible according to the call-by-value rules.
// If no reduction is possible, returns None.
def reduce(t: ULTerm): Option[ULTerm] = t match {

  // Case: the left term is an abstraction, and the right is a value.
  // Then apply the value to the abstraction.
  case ULApp(ULAbs(t),v) if isValue(v) =>
    // When we apply the value to the abstraction,
    // we must shift the value's free variables up by 1 to account
    // for the abstraction's variable binder.
    val r = substitute(t,0,shift(1,v))
    // Then, we need to shift the result back.
    // Since the abstraction's variable is now "used up".
    Some(shift(-1,r))

  // Case: the left term is a value, then try to reduce the right term.
  case ULApp(v,t) if isValue(v) =>
    reduce(t) match {
      case Some(r) => Some(ULApp(v,r))
      case None => None
    }

  // Case: the left term is not a value (not an abstraction.)
  // Try to reduce it.
  case ULApp(t1,t2) =>
    reduce(t1) match {
      case Some(r1) => Some(ULApp(r1,t2))
      case None => None
    }
    
  case _ => None
}

// Evaluation just repeatedly applies reduce,
// until we reach None (signifying reduction failed.)
def evaluate(t: ULTerm): ULTerm = reduce(t) match {
  case None => t
  case Some(r) => evaluate(r)
}
\end{minted}

\subsection*{Ruby implementation}
\label{sec:org0c3e2e3}
In Ruby, we use implement \emph{UL} terms using a (super) class \texttt{ULTerm} with
subclasses for each kind of \emph{UL} term.

The super class defines so default methods to keep track
of what kind of term we have.
These could be implemented as fields (instance variables),
but the use of methods implies that these values are constant
for all objects and across all time.
\begin{minted}[breaklines=true]{ruby}
# Our top-level ULTerm class defines some default
# methods to track what kind of term we have
# (which must be overidden in non-default cases)
# as well as the shift, substitute and eval methods
# which are defined in terms of other methods
# defined by the subclasses.
class ULTerm

  # By default, we assume terms are irreducible,
  # not abstractions, and not values.
  # Subclasses which should have these properties
  # must override these methods.
  # (In our basic calculus with call-by-value semantics,
  # only applications are reducible and only abstractions
  # are values. This can be changed for different calculi/semantics.)
  def reduce; nil end
  def absBody; nil end
  def isValue?; false end
\end{minted}

We would not usually have enough information in this super \texttt{ULTerm} class
to be able to define the \texttt{shift} and \texttt{substitution} methods,
without resorting to (what I feel is) an ugly approach of using \texttt{is\_a?} to check
whether the term is a variable, abstraction or application.

Previously, we used a local \texttt{walk} method inside of each of
the methods, which actually carried out the work on the terms.
We could do the same here, repeating the definition of \texttt{walk} inside of
the \texttt{shift} and \texttt{substitute} methods for each type of term
(at least, I believe we can do so.)
However, this repetition of code is very undesirable.

Instead, we take advantage of the fact that the \texttt{walk} method
was in fact \emph{almost identical} for both shifting and substitution,
only acting differently on \emph{variables}, to reimagine \texttt{walk} as
an iterator. This iterator will take as a block argument (a lambda)
the action to carry out on variables.

So, assuming that the \texttt{walk} method will be defined for each of the subclasses,
we can define \texttt{shift} and \texttt{substitute} here in the superclass
by writing the action to take on variables as a block,
and calling \texttt{walk} on the term with that action.
\begin{minted}[breaklines=true]{ruby}
  # Shifting is just walking, where in the base case,
  # we either increment the variable by shiftAmount or
  # leave it alone.
  def shift(shiftAmount)
    # walk is an iterator.
    # The block tells us what to do with variables.
    walk(0) { |x,currentBinders|
      if x >= currentBinders
        ULVar.new(x+shiftAmount)
      else
        ULVar.new(x)
      end }
  end

  # Substitution is just walking, where we either
  # replace the variable, or leave it alone.
  def substitute(x,r)
    walk(0) { |y,currentBinders|
      if y == x + currentBinders
        r
      else
        ULVar.new(y)
      end }
  end
\end{minted}

Similarly to how we assume above that the \texttt{walk} method
will be defined for all subclasses, we also assume
that the \texttt{reduce} method will be defined for all subclasses,
since we lack a nice means to define it here.
However, we can easily define \texttt{eval} in terms of those \texttt{reduce} methods.
\begin{minted}[breaklines=true]{ruby}
  def eval
    r = nil
    r_next = self
    # Keep reducing until it fails (reduce returns nil.)
    # This is the recommended "do...while" form in Ruby.
    loop do
      r = r_next
      r_next = r.reduce
      break unless r_next
    end

    return r
  end
end
\end{minted}

As mentioned above, in each of the subclasses of \texttt{ULTerm},
we need to define the \texttt{walk} and \texttt{reduce} methods.
But for variables, reduction is undefined, so we
do not define that method here.
(We do define here and below \texttt{to\_s} methods, to allow
these terms to be printed somewhat nicely.)
\begin{minted}[breaklines=true]{ruby}
class ULVar < ULTerm
  attr_reader :index

  # We require our variables are only indexed by integers.
  def initialize(i)
    unless i.is_a?(Integer)
      throw "Constructing a lambda term out of non-lambda terms"
    end
    @index = i
  end
  
  def walk(currentBinders,&block)
    # This is a variable. Run the code in &block.
    # (yield does this; it "yields" control to the block.)
    yield(@index, currentBinders)
  end

  def to_s
    @index.to_s
  end

  def ==(r); r.is_a?(ULVar) && r.index == @index end
end
\end{minted}

Again, we cannot \texttt{reduce} an abstraction,
so we do not define that method here.
But we do set override the \texttt{absBody} and \texttt{isValue?} methods
since this is an abstraction, and abstractions are values.
\begin{minted}[breaklines=true]{ruby}
class ULAbs < ULTerm
  attr_reader :t

  def initialize(t)
    unless t.is_a?(ULTerm)
      throw "Constructing a lambda term out of a non-lambda term"
    end
    @t = t
  end
  
  def walk(currentBinders,&block)
    # Increment the local variable counter within the variable binder.
    t = @t.walk(currentBinders+1,&block)
    ULAbs.new(t)
  end

  # Abstractions are an abstraction (of course),
  # with body @t,
  # and are also considered values.
  def absBody; @t end
  def isValue?; true end
  
  def to_s
    "lambda . " + @t.to_s
  end

  def ==(r); r.is_a?(ULAbs) && r.t == @t end
end
\end{minted}

The application subclass is actually the only one
where we define the \texttt{reduce} method.
The logic of it is the same as in the Scala version,
though unfortunately the lack of pattern matching
makes it appear much worse.
(The source code was edited November 6th to remove some
diagnostic printing statements which were unfortunately included previously.)
\begin{minted}[breaklines=true]{ruby}
class ULApp < ULTerm
  attr_reader :t1
  attr_reader :t2

  def initialize(t1,t2)
    unless t1.is_a?(ULTerm) && t2.is_a?(ULTerm)
      throw "Constructing a lambda term out of non-lambda terms"
    end
    @t1 = t1; @t2 = t2
  end
  
  def walk(currentBinders,&block)
    t1 = @t1.walk(currentBinders,&block)
    t2 = @t2.walk(currentBinders,&block)
    ULApp.new(t1,t2)
  end

  # Applications can be reduced.
  def reduce
    if @t1.absBody && @t2.isValue?
      body = @t1.absBody
      (body.substitute(0,@t2.shift(1))).shift(-1)
    elsif @t1.isValue?
      r = @t2.reduce
      if r
        ULApp.new(@t1,r)
      else
        nil
      end
    else
      r = @t1.reduce
      if r
        ULApp.new(r,@t2)
      else
        nil
      end
    end
  end

  def to_s
    "(" + @t1.to_s + ") (" + @t2.to_s + ")" 
  end

  def ==(r); r.is_a?(ULApp) && r.t1 == @t1 && r.t2 == @t2 end
end
\end{minted}

One important fact bears mentioning about our implementation
of \texttt{ULTerm} and its subclasses: note that all of the fields
of each class are read-only, and that their values
are only ever set in the constructors.
These are \emph{value classes}; a \texttt{ULTerm} object is intended to be
(and will be, barring any misuse) \emph{immutable} (unchanging over time.)

This design leads to better predictability of code;
there should never be an instance where a \texttt{ULTerm} changes unexpectedly
because of some method call, because \texttt{ULTerm}'s never change
after their creation.

\subsection*{Examples of interacting with these representations}
\label{sec:org952093c}
The following code snippets show how you might use
these implementations to perform some simple computations.

In Scala:
\begin{minted}[breaklines=true]{scala}
// The term "lambda x . lambda y . lambda z . u (x (y z))"
// Note the first variable (The one initialised with ULVar(3)) is free,
// because it's index is greater than the number of abstractions
// surrounding it.
val x = ULAbs(
          ULAbs(
            ULAbs(ULApp(ULVar(3),
                        ULApp(ULVar(2),
                              ULApp(ULVar(1),
                                    ULVar(0)))))))
println("An unnamed representation of lambda x . lambda y . lambda z -> u x y z:")
print("\t")
println(x)

// Now substitute that term itself in for the free variable.
println("The result of substituting that term into itself for the variable u:")
print("\t")
println(substitute(x,0,x))
\end{minted}

And in Ruby:
\begin{minted}[breaklines=true]{ruby}
# The term "lambda x . lambda y . lambda z . u (x (y z))"
# Note the first variable (The one initialised with ULVar.new(3)) is free,
# because it's index is greater than the number of abstractions
# surrounding it.
x = ULAbs.new(
      ULAbs.new(
        ULAbs.new(ULApp.new(ULVar.new(3),
                            ULApp.new(ULVar.new(2),
                                      ULApp.new(ULVar.new(1),
                                                ULVar.new(0)))))))
puts "An unnamed representation of lambda x . lambda y . lambda z -> u x y z:"
print "\t"
puts x

# Now substitute that term itself in for the free variable.
puts "The result of substituting that term into itself for the variable u:"
print "\t"
puts x.substitute(0,x)

# Note that the term itself remains unchanged;
# we've made sure this type is immutable
# by always creating new terms, or reusing them if that's not necessary,
# in the class methods. The fields are only ever changed in the constructors.
puts x
\end{minted}

\section*{Part 1 – The representation                                  [10 marks]}
\label{sec:orgc5213af}
\begin{center}
\textbf{Place your code for this part in the files \texttt{a2.sc} and \texttt{a2.rb}.}
\end{center}

Implement, in both Scala and Ruby,
a type \texttt{STTerm} to represent terms of the λ-calculus \emph{ST} defined above.

The constructors of the type should be named
\begin{itemize}
\item \texttt{STVar},
\item \texttt{STApp},
\item \texttt{STAbs},
\item \texttt{STZero},
\item \texttt{STSuc},
\item \texttt{STIsZero},
\item \texttt{STTrue},
\item \texttt{STFalse}, and
\item \texttt{STTest}.
\end{itemize}

(The remaining text of this section was added November 10th.)

The \texttt{STZero}, \texttt{STTrue} and \texttt{STFalse} types should be declared as
singleton classes in Scala (i.e., as \texttt{case object}'s instead of \texttt{case class}'s.)

Note that the \texttt{STAbs} constructor must take an argument specifying
the \emph{type} of the variable being abstracted. This argument
should be of the following types.
(This code should be included in your \texttt{a2} file.)
In \href{./src/a2\_types.sc}{Scala}:
\begin{minted}[breaklines=true]{scala}
sealed trait STType
case object STNat extends STType {
  override def toString() = "nat"
}
case object STBool extends STType {
  override def toString() = "bool"
}
// Functions have a domain type and a codomain type.
case class STFun(dom: STType, codom: STType) extends STType {
  override def toString() = "(" + dom.toString + ") -> (" + codom.toString + ")"
}

// Example use: the type "nat -> bool" is written STFun(STNat,STBool)
\end{minted}
And in \href{./src/a2\_types.rb}{Ruby}:
\begin{minted}[breaklines=true]{ruby}
class STType end

class STNat < STType
  # Comparison and printing methods
  def ==(type); type.is_a?(STNat) end
  def to_s; "nat" end
end

class STBool < STType
  # Comparison and printing methods
  def ==(type); type.is_a?(STBool) end
  def to_s; "bool" end
end

# Functions have a domain type and a codomain type.
class STFun < STType
  attr_reader :dom
  attr_reader :codom
  
  def initialize(dom, codom)
    unless dom.is_a?(STType) && dom.is_a?(STType)
      throw "Constructing a type out of non-types"
    end
    @dom = dom; @codom = codom
  end

  # Comparison and printing methods
  def ==(type); type.is_a?(STFun) && type.dom == @dom && type.codom == @codom end 
  def to_s; "(" + dom.to_s + ") -> (" + codom.to_s + ")" end
end

# Example use: the type "nat -> bool" is written STFun.new(STNat.new,STBool.new)
\end{minted}

\section*{Part 2 – Type checking                                       [40 marks]}
\label{sec:orge4c50f0}
\begin{center}
\textbf{Place your code for this part in the files \texttt{a2.sc} and \texttt{a2.rb}.}
\end{center}

Implement, in both Scala and Ruby,
a \emph{type checker} method named \texttt{typecheck} for elements of \texttt{STTerm}.

This \texttt{typecheck} method takes an \texttt{STTerm}, and returns \texttt{true} if
the represented term obeys the type rules of \emph{ST};
otherwise, it returns \texttt{false}.

(The remaining text of this section was added November 10th.)

The definition of \texttt{typecheck} will require a method to determine
the type of a given expression.
The name \texttt{typeOf} is recommended for this method.
This method should have as an argument the \emph{environment};
i.e., a map, list or similar type which relates variables to types. 
(Since variables are represented as integers,
this means relating integers to \texttt{STType} values.)

I (Mark) \emph{suggest} that \texttt{typeOf} method return a \texttt{Option[STType]} in the Scala implementation,
but this is not a requirement.
You will not be penalised for using any reasonable implementation,
including
\begin{itemize}
\item use of exceptions when a term has no type,
\item use of the \texttt{Try}, \texttt{Success} and \texttt{Failure} types, or
\item use of the \texttt{Either} type.
\end{itemize}
If you have another implementation in mind, you are welcome to check
with Mark.

\section*{Part 3 – Translation to the untyped λ-calculus; type erasure [40 marks]}
\label{sec:orgbea0016}
\begin{center}
\textbf{Place your code for this part in the files \texttt{a2.sc} and \texttt{a2.rb}.}
\end{center}

Implement, in both Scala and Ruby,
a method \texttt{eraseTypes} for elements of \texttt{STTerm},
which \emph{translates} them into elements of \texttt{ULTerm} (definition given above.)

This translation also needs to translate the natural and boolean constants
into the pure λ-calculus encodings that represent them.
Recall these translations from the notes (the translation for \texttt{iszero} has been added.)
\begin{minted}[breaklines=true]{text}
true   = λ t → λ f → t
false  = λ t → λ f → f
test   = λ l → λ m → λ n → l m n
zero   = λ s → λ z → z
suc    = λ n → λ s → λ z → s (n s z)
iszero = λ m → m (λ x → false) true     
\end{minted}
Bear in mind that application is left-associative, so, e.g., \texttt{l m n} is
equivalent to \texttt{(l m) n}.

(You should import the \texttt{a2\_ulterm} files into your file
in a manner compatible with the Docker testing environments,
or copy the definitions into your file and create
blank \texttt{a2\_ulterm} files to satisfy the import statements in the testing.)

\section*{Part 4 – Bonus: Interpreting \emph{SL} programs                     [10 marks]}
\label{sec:orga262982}
\begin{center}
\textbf{Place any code for this part in files \texttt{a2p4.sc} and \texttt{a2p4.rb}.}
\end{center}

Implement an evaluation method for your \texttt{STTerm} type.

Make use of the evaluation method for \texttt{ULTerm}'s in your definition.
You will also need a method to convert results back
to an \texttt{STTerm} representation.

\section*{Part 5 – Bonus: pairs                                        [10 bonus marks]}
\label{sec:org20b6ae1}
\begin{center}
\textbf{Place any code for this part in files \texttt{a2p5.sc} and \texttt{a2p5.rb}.}
\end{center}

Implement another λ-calculus, called \emph{ST2}, which includes
the type of \emph{pairs} as well as naturals and booleans,
along with a type checker, type eraser and evaluation method.

\section*{Submission checklist}
\label{sec:org3da321c}
For your convenience, this checklist is provided
to track the files you need to submit.
Use it if you wish.
\begin{minted}[breaklines=true]{text}
- [ ] Documentation; one of
  - [ ] README.html
  - [ ] README.pdf
  - [ ] README.md
  - [ ] README.org
- [ ] Code files
  - [ ] a2.sc
  - [ ] a2.rb
- [ ] Part 2 tests
  - [ ] a2p2_test.sc tests have passed! (No submission needed.)
  - [ ] a2p2_test.rb tests have passed! (No submission needed.)
- [ ] Part 3 tests
  - [ ] a2p3_test.sc tests have passed! (No submission needed.)
  - [ ] a2p3_test.rb tests have passed! (No submission needed.)
- [ ] Part 4 (Bonus)
  - [ ] a2p4.sc
  - [ ] a2p4.rb
\end{minted}

\section*{Testing}
\label{sec:org89fee43}
Unit tests for the requested types, methods and predicates
are available here.
\begin{itemize}
\item \href{./testing/a1/a1p1\_test.sc}{a2\_test.sc}
\item \href{./testing/a1/a1p2.plt}{a2\_test.rb}
\end{itemize}
The contents of the unit test files are also repeated below.

The tests can be run by placing the test files
in the same directory as your code files.

To run the tests for the Scala portions, use the command
\begin{minted}[breaklines=true]{shell}
amm a2_test.sc
\end{minted}

To run the tests for the Ruby portions,us the commands
\begin{minted}[breaklines=true]{shell}
ruby a2_test.rb
\end{minted}

\begin{center}
\textbf{You are strongly encouraged to add your own additional test cases}
\textbf{to those provided for you.}

The provided test cases check a very minimal amount!
\end{center}

\subsection*{Automated testing via Docker}
\label{sec:org2c12019}
The Docker setup and usage scripts are available at the following links.
Their contents are also repeated below.
\begin{itemize}
\item \href{./testing/a2/Dockerfile}{Dockerfile}
\item \href{./testing/a2/docker-compose.yml}{docker-compose.yml}
\item \href{./testing/a2/setup.sh}{setup.sh}
\item \href{./testing/a2/run.sh}{run.sh}
\end{itemize}
Place them into your \texttt{a2} directory where your code files
and the test files (linked to above) exist,
then run \texttt{setup.sh} and \texttt{run.sh}.

Note that the use of the \texttt{setup.sh} and \texttt{run.sh} scripts assumes
that you are in a \texttt{bash} like shell; if you are on Windows,
and not using WSL or WSL2, you may have
to run the commands contained in those scripts manually.

\subsection*{The tests}
\label{sec:org148a033}
\subsubsection*{Scala}
\label{sec:org980b42b}
\href{./testing/a2/a2\_testframework.sc}{a2\_test.sc}
\begin{minted}[breaklines=true]{scala}
import $file.a2, a2._
import $file.a2_ulterm, a2_ulterm._

/* Given an expected result and a computed result,
   check if they are equal in value.
   If so, return 0. Otherwise, inform the user, and return 1,
   so the number of failures can be counted. */
def test[A](given: A, expected: A, the_test: String) =
  if (!(given equals expected)) {
    println("+---------------------------------------------------")
    println("| " + the_test + " failed.")
    println("| Expected " + expected + ", got " + given + ".")
    println("+---------------------------------------------------")
    1
  } else {
    0
  }

val providedTests : List[Tuple3[Unit => Any, Any, String]] = List(

  // Positive typechecking test cases
  (_ => typecheck(STZero),                       true, "Typecheck zero"),
  (_ => typecheck(STSuc(STZero)),                true, "Typecheck one"),
  (_ => typecheck(STIsZero(STZero)),             true, "Typecheck iszero zero"),
  (_ => typecheck(STTrue),                       true, "Typecheck true"),
  (_ => typecheck(STFalse),                      true, "Typecheck false"),
  (_ => typecheck(STTest(STTrue,STZero,STZero)), true, "Typecheck test true zero zero"),
  (_ => typecheck(STAbs(STNat,STVar(0))),        true, "Typecheck lambda x : nat . x"),
  (_ => typecheck(STApp(STAbs(STNat,STVar(0)),STZero)), true, "Typecheck (lambda x : nat . x) (zero)"),

  
  // Negative typechecking test cases
  (_ => typecheck(STSuc(STFalse)), false,
    "Successor of false should not typecheck."),
  (_ => typecheck(STVar(0)), false,
    "Free variables should not typecheck"),
  (_ => typecheck(STApp(STAbs(STNat,STVar(0)),STFalse)), false,
    "Applying a boolean to a natural function should not typecheck"),

  // Type erasure tests
  (_ => eraseTypes(STTrue), ULAbs(ULAbs(ULVar(1))), "Erase types of true"),
  (_ => eraseTypes(STSuc(STZero)),
    ULApp(
      // Encoding of suc
      ULAbs( // lambda n .
        ULAbs( // lambda s.
          ULAbs( // lambda z.
            ULApp(ULVar(1),ULApp(ULApp(ULVar(2),ULVar(1)),ULVar(0)))))), // s (n s z)
      // Encoding of zero
      ULAbs( // lambda s .
        ULAbs( // lambda z .
          ULVar(0)))), // z
    "Erase types of one"),
  (_ => eraseTypes(STApp(STAbs(STNat,STVar(0)),STZero)),
    ULApp(ULAbs(ULVar(0)), ULAbs(ULAbs(ULVar(0)))),
    "Erase types of (lambda x : nat . x) (zero)"),
)

def runTests[A](tests: List[Tuple3[Unit => A,A,String]]): Unit = {
  // Apply test to each element of tests, and sum the return values.
  // This is essentially a for loop.
  val failed = tests.foldLeft(0) {
    (failures, next) => next match {
      // Deconstruct the tuple to get its parts
      case (given, expected, the_test) => {
        val failure = try {
          test(given(), expected, the_test)
        } catch {
          case e: Exception => {
            print("Test " + the_test + "encountered exception: ")
            println(e)
            1
          }
        }
        failures + failure
      }
    }
  }
  
  println("+---------------------------------------------------")
  println("| " + failed + " tests failed")
  println("+---------------------------------------------------")
}

runTests(providedTests)
\end{minted}

\subsubsection*{Ruby}
\label{sec:orgb0f4d9f}
\href{./testing/a2\_test.rb}{a2\_test.rb}
\begin{minted}[breaklines=true]{ruby}
require_relative "a2"
require_relative "a2_ulterm"
require "test/unit"

class ProvidedTests < Test::Unit::TestCase

  # Positive type checking tests
  def test_simple0
    assert_equal(true, STZero.new.typecheck, "Typecheck zero")
  end
  def test_simple1
    assert_equal(true, STSuc.new(STZero.new).typecheck, "Typecheck one")
  end
  def test_simple2
    assert_equal(true, STIsZero.new(STZero.new).typecheck, "Typecheck iszero zero")
  end
  def test_simple3
    assert_equal(true, STTrue.new.typecheck, "Typecheck true")
  end
  def test_simple4
    assert_equal(true, STFalse.new.typecheck, "Typecheck false")
  end
  def test_simple5
    assert_equal(true,
                 STTest.new(STTrue.new,STZero.new,STZero.new).typecheck,
                 "Typecheck test true zero zero")
  end
  def test_simple6
    assert_equal(true,
                 STAbs.new(STNat.new,STVar.new(0)).typecheck,
                 "Typecheck lambda x : nat . x")
  end
  def test_simple7
    assert_equal(true,
                 STApp.new(STAbs.new(STNat.new,STVar.new(0)),STZero.new).typecheck,
                 "Typecheck (lambda x : nat . x) (zero)")
  end

  # Negative typechecking tests  
  def test_simple8
    assert_equal(false,
                 STSuc.new(STFalse.new).typecheck,
                 "Successor of false should not typecheck.")
  end
  def test_simple9
    assert_equal(false,
                 STVar.new(0).typecheck,
                 "Free variables should not typecheck")
  end
  def test_simple10
    assert_equal(false,
                 STApp.new(STAbs.new(STNat.new,STVar.new(0)),STFalse.new).typecheck,
                 "Applying a boolean to a natural function should not typecheck")
  end

  def test_simple11
    assert_equal(ULAbs.new(ULAbs.new(ULVar.new(1))), STTrue.new.eraseTypes, "Erase types of true")
  end
  def test_simple12
    assert_equal(ULApp.new(
                   # Encoding of suc
                   ULAbs.new( # lambda n .
                     ULAbs.new( # lambda s.
                       ULAbs.new( # lambda z.
                         ULApp.new(ULVar.new(1),ULApp.new(ULApp.new(ULVar.new(2),ULVar.new(1)),ULVar.new(0)))))), # s (n s z)
                   # Encoding of zero
                   ULAbs.new( # lambda s .
                     ULAbs.new( # lambda z .
                       ULVar.new(0)))), # z
                 STSuc.new(STZero.new).eraseTypes,
                 "Erase types of one")
  end
  def test_simple13
    assert_equal(ULApp.new(ULAbs.new(          ULVar.new(0)),ULAbs.new(ULAbs.new(ULVar.new(0)))),
                 STApp.new(STAbs.new(STNat.new,STVar.new(0)),STZero.new).eraseTypes,
                 "Erase types of (lambda x : nat . x) (zero)")
  end
end
\end{minted}

\subsection*{The Docker setup}
\label{sec:org8b9a6b7}
\href{./testing/a2/Dockerfile}{Dockerfile}
\begin{minted}[breaklines=true]{docker}
# Define the argument for openjdk version
ARG OPENJDK_TAG=8u232

FROM ruby:2.7.2-buster

# Setup to install Scala
RUN apt-get update && \
    apt-get install scala -y && \
    apt-get install -y curl && \
    sh -c '(echo "#!/usr/bin/env sh" && \
    curl -L https://github.com/lihaoyi/Ammonite/releases/download/2.1.1/2.12-2.1.1) > /usr/local/bin/amm && \
    chmod +x /usr/local/bin/amm'
RUN (rm -rf /root/.cache)
     
# Set the name of the maintainers
MAINTAINER Habib Ghaffari Hadigheh, Mark Armstrong <ghaffh1@mcmaster.ca, armstmp@mcmaster.ca>

# Set the working directory
WORKDIR /opt/a2
\end{minted}

\href{./testing/a2/docker-compose.yml}{docker-compose.yml}
\begin{minted}[breaklines=true]{yaml}
version: '2'
services:
  service:
    build: .
    image: 3mi3_a2_docker_image
    volumes:
      - .:/opt/a2
    container_name: 3mi3_a2_container
    command: bash -c
      "echo 'Scala testing' &&
       echo '----------------------------------------------------------------------' &&
       amm a2_test.sc &&
       printf '\\n\\n\\n' &&
       echo 'Ruby testing' &&
       echo '----------------------------------------------------------------------' &&
       ruby a2_test.rb &&
       echo '----------------------------------------------------------------------'"
\end{minted}

\href{./testing/a2/setup.sh}{setup.sh}
\begin{minted}[breaklines=true]{shell}
docker-compose build --force-rm
\end{minted}

\href{./testing/a2/run.sh}{run.sh}
\begin{minted}[breaklines=true]{shell}
# Run the container
docker-compose up --force-recreate
# Stop the container after finishing the test run
docker-compose stop -t 1
\end{minted}
\end{document}
