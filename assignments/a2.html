<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-11-10 Tue 15:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Computer Science 3MI3 – 2020 assignment 2</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Mark Armstrong" />
<meta name="description" content="Type checking and erasing on a simply-typed λ-calculus."
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/readtheorg.css"/>
<script type="text/javascript" src="styles/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="styles/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="styles/readtheorg/js/readtheorg.js"></script>
<style>pre.src{background:#000000;color:white;} </style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Computer Science 3MI3 – 2020 assignment 2
<br />
<span class="subtitle">Typing a λ-calculus</span>
</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Updates-and-file-history">Updates and file history</a>
<ul>
<li><a href="#November-10th">November 10th</a></li>
<li><a href="#November-6th">November 6th</a></li>
<li><a href="#November-5th">November 5th</a></li>
<li><a href="#November-1st">November 1st</a></li>
<li><a href="#October-30th">October 30th</a></li>
</ul>
</li>
<li><a href="#Boilerplate">Boilerplate</a>
<ul>
<li><a href="#Submission-procedures">Documentation</a></li>
<li><a href="#Submission-procedures">Submission procedures</a>
<ul>
<li><a href="#org5f75fe6">Assignment naming requirements</a></li>
</ul>
</li>
<li><a href="#Proper-conduct-for-coursework">Proper conduct for coursework</a></li>
</ul>
</li>
<li><a href="#Informal-description-of-the-expression-language">Part 0.1 – Description of the λ-calculus, <i>ST</i>                 [0 marks]</a></li>
<li><a href="#Part-0.2-–-A-representation-of-the-untyped-λ-calculus,-/UL/----[0 marks]">Part 0.2 – A representation of the untyped λ-calculus, <i>UL</i>    [0 marks]</a>
<ul>
<li><a href="#Nameless-representation-of-terms">Nameless representation of terms</a></li>
<li><a href="#Scala-implementation">Scala implementation</a></li>
<li><a href="#Ruby-implementation">Ruby implementation</a></li>
<li><a href="#Examples-of-interacting-with-these-representations">Examples of interacting with these representations</a></li>
</ul>
</li>
<li><a href="#Part-1-–-The-representation----------------------------------[10 marks]">Part 1 – The representation                                  [10 marks]</a></li>
<li><a href="#Part-1-–-Interpreter-written-in-Scala--[20 marks]">Part 2 – Type checking                                       [40 marks]</a></li>
<li><a href="#Part-2-–-Interpreter-written-in-Prolog-[20 marks]">Part 3 – Translation to the untyped λ-calculus; type erasure [40 marks]</a></li>
<li><a href="#Part-4-–-Bonus:-Interpreting-/SL/-programs---------------------[10 marks]">Part 4 – Bonus: Interpreting <i>SL</i> programs                     [10 marks]</a></li>
<li><a href="#Part-5-–-Bonus:-pairs----------------------------------------[10 bonus marks]">Part 5 – Bonus: pairs                                        [10 bonus marks]</a></li>
<li><a href="#Submission-checklist">Submission checklist</a></li>
<li><a href="#Testing">Testing</a>
<ul>
<li><a href="#Automated-testing-via-Docker">Automated testing via Docker</a></li>
<li><a href="#The-tests">The tests</a>
<ul>
<li><a href="#Scala">Scala</a></li>
<li><a href="#Ruby">Ruby</a></li>
</ul>
</li>
<li><a href="#The-Docker-setup">The Docker setup</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-Introduction" class="outline-2">
<h2 id="Introduction">Introduction</h2>
<div class="outline-text-2" id="text-Introduction">
<p>
This assignment asks you to construct representation
of a simply-typed λ-calculus, construct a typechecker for that
λ-calculus, and finally to implement <i>type-erasure</i> and a
simple translator to simplify terms to untyped λ-calculus terms.
</p>
</div>
</div>

<div id="outline-container-Updates-and-file-history" class="outline-2">
<h2 id="Updates-and-file-history">Updates and file history</h2>
<div class="outline-text-2" id="text-Updates-and-file-history">
</div>

<div id="outline-container-November-10th" class="outline-3">
<h3 id="November-10th">November 10th</h3>
<div class="outline-text-3" id="text-November-10th">
<ul class="org-ul">
<li>The testing section has been completed.</li>
<li>The subclasses of the <code>ULTerm</code> class in Ruby have had
a <code>==</code> method added to them. This method
is necessary for the testing of Part 3,
and you will need to copy its definitions or
re-download the <a href="./src/a2_ulterm.rb"><code>a2_ulterm.rb</code></a> file.</li>
<li>Notes about the means of implementing type checking have been added.</li>
<li>The names of the types for natural numbers and booleans
in the <i>ST</i> language have been shortened, to <code>nat</code> and <code>bool</code>.
<ul class="org-ul">
<li>Classes to represent these types in both Scala and Ruby
have also been provided.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-November-6th" class="outline-3">
<h3 id="November-6th">November 6th</h3>
<div class="outline-text-3" id="text-November-6th">
<ul class="org-ul">
<li>The typing rules for the <i>ST</i> language were added
in part 0.1.</li>
</ul>
</div>
</div>

<div id="outline-container-November-5th" class="outline-3">
<h3 id="November-5th">November 5th</h3>
<div class="outline-text-3" id="text-November-5th">
<ul class="org-ul">
<li>A typo in a variable name in the Ruby implementation
of <code>ULTerm</code> was corrected.</li>
<li>The provided Scala code for the <code>ULTerm</code> type was modified
slightly to include better <code>toString</code> methods.</li>
<li>Example code showing how to construct <code>ULTerm</code> terms
and perform substitutions with them was added to part 0.2.</li>
</ul>
</div>
</div>

<div id="outline-container-November-1st" class="outline-3">
<h3 id="November-1st">November 1st</h3>
<div class="outline-text-3" id="text-November-1st">
<ul class="org-ul">
<li>Part 4 was made bonus
<ul class="org-ul">
<li>and the task of translating from <code>ULTerm</code>'s to <code>STTerm</code>'s was
made part of the question.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-October-30th" class="outline-3">
<h3 id="October-30th">October 30th</h3>
<div class="outline-text-3" id="text-October-30th">
<ul class="org-ul">
<li>Initial version posted.
<ul class="org-ul">
<li>Testing not posted yet.</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-Boilerplate" class="outline-2">
<h2 id="Boilerplate">Boilerplate</h2>
<div class="outline-text-2" id="text-Boilerplate">
</div>

<div id="outline-container-Submission-procedures" class="outline-3">
<h3 id="Submission-procedures">Documentation</h3>
<div class="outline-text-3" id="text-Submission-procedures">
<p>
In addition to the code for the assignments,
you are required to submit (relatively light) documentation,
along the lines of that found in
<a href="https://armkeh.github.io/principles-of-programming-languages/#outline-container-Lecture-literate-programs">the literate programs</a>
from lectures and tutorials.
</p>
<ul class="org-ul">
<li>Those occasionally include a lot of writing when introducing concepts;
you do not have to introduce concepts, so your documentation
should be similar to the <i>end</i> of those documents,
where only the purpose and implementation details
of types, functions, etc., are discussed.</li>
</ul>

<p>
This documentation is not assigned its own marks;
rather, 20% of the marks of each part of the assignment
will be for the documentation.
</p>

<p>
This documentation <b>must be</b> in the literate style,
with (nicely typeset) English paragraphs alongside code snippets;
comments in your source code do not count.
The basic requirement is
</p>
<ul class="org-ul">
<li>the English paragraphs must use non-fixed width font, whereas</li>
<li>the code snippets must use fixed width font.</li>
<li>For example, see these lecture notes on Prolog:
<ul class="org-ul">
<li><a href="https://courses.cs.washington.edu/courses/cse341/98sp/logic/prolog.html">https://courses.cs.washington.edu/courses/cse341/98sp/logic/prolog.html</a></li>
</ul></li>
</ul>
<p>
But you are encouraged to strive for nicer than just
“the basic requirement”.
(the ability to write decent looking documentation is an asset!
</p>

<p>
You are free to present your documentation in any of these formats:
</p>
<ul class="org-ul">
<li>an HTML file,
<ul class="org-ul">
<li>(named <code>README.html</code>)</li>
</ul></li>
<li>a PDF (for instance, by writing it in LaTeX using
the <code>listings</code> or <code>minted</code> package for your code blocks),
<ul class="org-ul">
<li>(named <code>README.pdf</code>), or</li>
</ul></li>
<li>rendering on GitLab (for instance, by writing it in markdown or Org)
<ul class="org-ul">
<li>(named <code>README.md</code> or <code>README.org</code>.)</li>
</ul></li>
</ul>
<p>
If you wish to use another format, contact Mark to discuss it.
</p>

<p>
Not all of your code needs to be shown;
only portions which are of interest are needed.
Feel free to omit some “repetitive” portions.
(For instance, if there are several cases in a definition
which look almost identical, only one or two need to be shown.)
</p>
</div>
</div>

<div id="outline-container-Submission-procedures" class="outline-3">
<h3 id="Submission-procedures">Submission procedures</h3>
<div class="outline-text-3" id="text-Submission-procedures">
<p>
The same guidelines as for homework
(which can be seen in any of the homework files)
apply to assignments, except for the differences below.
</p>
</div>

<div id="outline-container-org5f75fe6" class="outline-4">
<h4 id="org5f75fe6">Assignment naming requirements</h4>
<div class="outline-text-4" id="text-org5f75fe6">
<p>
Place all files for the assignment
inside a folder titled <code>an</code>, where <code>n</code> is the number of the assignment.
So, for assignment 1, use the folder <code>a1</code>, for assignment 2 the folder <code>a2</code>, etc.
Ensure you do not capitalise the <code>a</code>.
</p>

<p>
Each part of the assignments will direct you on where to
save your code for that part. Follow those instructions!
</p>

<div class="org-center">
<p>
<b>If the language supports multiple different file extensions,</b>
<b>you must still follow the extension conventions noted in the assignment.</b>
</p>
</div>

<div class="org-center">
<p>
<b>Incorrect naming of files may result in up to a 5% deduction in your grade.</b>
</p>
</div>
<p>
This is slightly decreased from the 10% for homeworks.
</p>
</div>
</div>
</div>

<div id="outline-container-Proper-conduct-for-coursework" class="outline-3">
<h3 id="Proper-conduct-for-coursework">Proper conduct for coursework</h3>
<div class="outline-text-3" id="text-Proper-conduct-for-coursework">
<p>
Refer to the homework code of conduct available in any of the homework files.
The same guidelines apply to assignments.
</p>
</div>
</div>
</div>

<div id="outline-container-Informal-description-of-the-expression-language" class="outline-2">
<h2 id="Informal-description-of-the-expression-language">Part 0.1 – Description of the λ-calculus, <i>ST</i>                 [0 marks]</h2>
<div class="outline-text-2" id="text-Informal-description-of-the-expression-language">
<p>
The λ-calculus you are to work with during this assignment
we call <i>ST</i>, standing for <i>simply typed</i>.
It adds to the pure untyped λ-calculus <i>UL</i>
terms <code>zero</code>, <code>suc</code>, <code>iszero</code>, <code>tt</code>, <code>ff</code>, and <code>test</code>, with the following syntax.
</p>
<div class="org-src-container">
<pre class="src src-text"><span style="color: #00cd68;">&#10216;</span>typedterm<span style="color: #00cd68;">&#10217;</span> &#8759;= var
             | <span style="color: #00cd68;">&#10216;</span>typedterm<span style="color: #00cd68;">&#10217;</span> <span style="color: #00cd68;">&#10216;</span>typedterm<span style="color: #00cd68;">&#10217;</span>
             | &#955; var : <span style="color: #00cd68;">&#10216;</span>type<span style="color: #00cd68;">&#10217;</span> &#8594; <span style="color: #00cd68;">&#10216;</span>typedterm<span style="color: #00cd68;">&#10217;</span>
             | zero
             | suc <span style="color: #00cd68;">&#10216;</span>typedterm<span style="color: #00cd68;">&#10217;</span>
             | iszero <span style="color: #00cd68;">&#10216;</span>typedterm<span style="color: #00cd68;">&#10217;</span>
             | true
             | false
             | test <span style="color: #00cd68;">&#10216;</span>typedterm<span style="color: #00cd68;">&#10217;</span> <span style="color: #00cd68;">&#10216;</span>typedterm<span style="color: #00cd68;">&#10217;</span> <span style="color: #00cd68;">&#10216;</span>typedterm<span style="color: #00cd68;">&#10217;</span>

<span style="color: #00cd68;">&#10216;</span>type<span style="color: #00cd68;">&#10217;</span> &#8759;= <span style="color: #00cd68;">&#10216;</span>type<span style="color: #00cd68;">&#10217;</span> &#8594; <span style="color: #00cd68;">&#10216;</span>type<span style="color: #00cd68;">&#10217;</span>
        | nat
        | bool
</pre>
</div>

<p>
We also introduce the following <i>typing rules</i> for these typed λ-terms.
The rules make use of a <i>typing context</i> or <i>type environment</i> Γ.
</p>

<p>
The first rule says that variables have the type they are given
by the environment Γ (assuming they are given a type at all.)
</p>
<div class="org-src-container">
<pre class="src src-text"> x : A &#8712; &#915;
&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211; T-Var
 &#915; &#8866; x : A
</pre>
</div>

<p>
The second rule says that if by adding “<code>x</code> has type <code>A</code>” to the environment,
we can conclude that <code>t₂</code> has type <code>B</code>, then
the term <code>λ x : A → t₂</code> has type <code>A → B</code>.
(Notice that this rule is the only time we add to the environment.)
</p>
<div class="org-src-container">
<pre class="src src-text"> &#915;,<span style="color: #00cd68;">(</span>x : A<span style="color: #00cd68;">)</span> &#8866; t&#8322; : B
&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211; T-Abs
 &#915; &#8866; &#955; x : A &#8594; t&#8322; : A &#8594; B
</pre>
</div>

<p>
The third rule says that if <code>t₁</code> has the function type <code>A → B</code>,
and <code>t₂</code> has the type <code>A</code>, then <code>t₂</code> applied to <code>t₁</code> has type <code>B</code>.
</p>
<div class="org-src-container">
<pre class="src src-text"> &#915; &#8866; t&#8321; : A &#8594; B    &#915; &#8866; t&#8322; : A
&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211; T-App
        &#915; &#8866; t&#8321; t&#8322; : B
</pre>
</div>

<p>
The remaining rules give the typings for the constants and
function terms added to this language.
</p>
<div class="org-src-container">
<pre class="src src-text">                                   &#915; &#8866; t : nat
&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211; T-zero      &#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211; T-suc
 &#915; &#8866; zero : nat                  &#915; &#8866; suc t : nat
                            
                            
                         
&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211; T-true    &#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211; T-false
 &#915; &#8866; true : bool               &#915; &#8866; false : bool


    &#915; &#8866; t : nat
&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211; T-iszero
 &#915; &#8866; iszero t : bool 


 &#915; &#8866; b : bool    &#915; &#8866; t&#8321; : A    &#915; &#8866; t&#8322; : A
&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211; T-test
            &#915; &#8866; test b t&#8321; t&#8322; : A
</pre>
</div>
</div>
</div>

<div id="outline-container-Part-0.2-–-A-representation-of-the-untyped-λ-calculus,-/UL/----[0 marks]" class="outline-2">
<h2 id="Part-0.2-–-A-representation-of-the-untyped-λ-calculus,-/UL/----[0 marks]">Part 0.2 – A representation of the untyped λ-calculus, <i>UL</i>    [0 marks]</h2>
<div class="outline-text-2" id="text-Part-0.2-–-A-representation-of-the-untyped-λ-calculus,-/UL/----[0 marks]">
</div>

<div id="outline-container-Nameless-representation-of-terms" class="outline-3">
<h3 id="Nameless-representation-of-terms">Nameless representation of terms</h3>
<div class="outline-text-3" id="text-Nameless-representation-of-terms">
<p>
We use <i>de Bruijn indices</i> in place of named variables.
The index “points” to a binder, or to a free variable.
</p>
<ul class="org-ul">
<li><code>0</code> points to the first enclosing variable binder,
or the first free variable if there are no enclosing binders.</li>
<li><code>1</code> points to the second enclosing variable binder,
or the <code>2-n</code>'th free variable if there are only <code>n</code> enclosing binders, <code>n ≤ 1</code>.</li>
<li><code>2</code> points to the third enclosing variable binder,
or the <code>3-n</code>'th free variable if there are only <code>n</code> enclosing binders, <code>n ≤ 2</code>.</li>
<li>…</li>
<li><code>i</code> points to the <code>i</code>'th enclosing variable binder,
or the <code>(i+1)-n</code>'th free variable if there are only <code>n</code> enclosing binders, <code>n ≤ i</code>.</li>
<li>…</li>
</ul>

<p>
This representation avoids any need for renaming variables
during substitution.
</p>

<p>
It does make terms less human readable;
we can correct for this by writing a <i>pretty printer</i> for λ-terms
(which will be the focus of a homework.)
</p>
</div>
</div>

<div id="outline-container-Scala-implementation" class="outline-3">
<h3 id="Scala-implementation">Scala implementation</h3>
<div class="outline-text-3" id="text-Scala-implementation">
<p>
Pure untyped λ-terms can only be variables, abstractions or applications.
(Updated November 5th) We include as parts of the case classes
overrides of the <code>toString</code> method, which improve the appearance
of these terms when they are converted to strings.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #f78fe7;">sealed</span> <span style="color: #b6a0ff;">trait</span> <span style="color: #6ae4b9;">ULTerm</span>
<span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">ULVar</span><span style="color: #00cd68;">(</span>index<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Int</span><span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #6ae4b9;">ULTerm</span> <span style="color: #00cd68;">{</span>
  <span style="color: #f78fe7;">override</span> <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">toString</span><span style="color: #b6a0ff;">()</span> <span style="color: #b6a0ff;">=</span> index.toString<span style="color: #b6a0ff;">()</span>
<span style="color: #00cd68;">}</span>
<span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">ULAbs</span><span style="color: #00cd68;">(</span>t<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ULTerm</span><span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #6ae4b9;">ULTerm</span> <span style="color: #00cd68;">{</span>
  <span style="color: #f78fe7;">override</span> <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">toString</span><span style="color: #b6a0ff;">()</span> <span style="color: #b6a0ff;">=</span> <span style="color: #79a8ff;">"lambda . "</span> + t.toString<span style="color: #b6a0ff;">()</span>
<span style="color: #00cd68;">}</span>
<span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">ULApp</span><span style="color: #00cd68;">(</span>t1<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ULTerm</span>, t2<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ULTerm</span><span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #6ae4b9;">ULTerm</span> <span style="color: #00cd68;">{</span>
  <span style="color: #f78fe7;">override</span> <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">toString</span><span style="color: #b6a0ff;">()</span> <span style="color: #b6a0ff;">=</span> <span style="color: #79a8ff;">"("</span> + t1.toString<span style="color: #b6a0ff;">()</span> + <span style="color: #79a8ff;">") ("</span> + t2.toString<span style="color: #b6a0ff;">()</span> + <span style="color: #79a8ff;">")"</span>
<span style="color: #00cd68;">}</span>
</pre>
</div>

<p>
The use of de Bruijn indices necessitates a method to
“shift” the indices of free variables up or down;
for instance, when applying a term to an abstraction,
we must shift them up to avoid capturing what should be free variables
in a variable binder.
</p>

<p>
Shifting is done by walking through the term,
incrementing the variable indices by the shift amount
if their index is greater than the number of enclosing binders.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Shift the numbering of unbound variables</span>
<span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">shift</span><span style="color: #00cd68;">(</span>shiftAmount<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Int</span>, t<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ULTerm</span><span style="color: #00cd68;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ULTerm</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00cd68;">{</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Walk through the term and shift all variables with index</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">greater than or equal to c, which is maintained to be</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">the number of variable binders (abstractions) outside the current subterm.</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">walk</span><span style="color: #b6a0ff;">(</span>currentBinders<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Int</span>, t<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ULTerm</span><span style="color: #b6a0ff;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ULTerm</span> <span style="color: #b6a0ff;">=</span> t <span style="color: #b6a0ff;">match</span> <span style="color: #b6a0ff;">{</span>
    <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Check if x is a free variable; that is,</span>
    <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">if the number x is greater than or equal to</span>
    <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">the number of variable binders encountered outside this subterm.</span>
    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">ULVar</span><span style="color: #6ae4b9;">(</span><span style="color: #00d3d0;">x</span><span style="color: #6ae4b9;">)</span> <span style="color: #b6a0ff;">if</span> <span style="color: #6ae4b9;">(</span>x &gt;= currentBinders<span style="color: #6ae4b9;">)</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">ULVar</span><span style="color: #6ae4b9;">(</span>x+shiftAmount<span style="color: #6ae4b9;">)</span>
    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">ULVar</span><span style="color: #6ae4b9;">(</span><span style="color: #00d3d0;">x</span><span style="color: #6ae4b9;">)</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">ULVar</span><span style="color: #6ae4b9;">(</span>x<span style="color: #6ae4b9;">)</span>

    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">ULAbs</span><span style="color: #6ae4b9;">(</span><span style="color: #00d3d0;">t</span><span style="color: #6ae4b9;">)</span> <span style="color: #b6a0ff;">=&gt;</span>
      <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">We now have one more variable binder outside the subterm.</span>
      <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Increment currentBinders and walk into the subterm.</span>
      <span style="color: #00bcff;">ULAbs</span><span style="color: #6ae4b9;">(</span>walk<span style="color: #f0ce43;">(</span>currentBinders+<span style="color: #00bcff;">1</span>, t<span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>

    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">ULApp</span><span style="color: #6ae4b9;">(</span><span style="color: #00d3d0;">t1</span>,<span style="color: #00d3d0;">t2</span><span style="color: #6ae4b9;">)</span> <span style="color: #b6a0ff;">=&gt;</span>
      <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">No new variable binders. Just walk into the subterms.</span>
      <span style="color: #00bcff;">ULApp</span><span style="color: #6ae4b9;">(</span>walk<span style="color: #f0ce43;">(</span>currentBinders,t1<span style="color: #f0ce43;">)</span>,walk<span style="color: #f0ce43;">(</span>currentBinders,t2<span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>
  <span style="color: #b6a0ff;">}</span>

  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Walk the term and perform the shift of free variables.</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">We begin with 0 variable binders outside.</span>
  walk<span style="color: #b6a0ff;">(</span><span style="color: #00bcff;">0</span>, t<span style="color: #b6a0ff;">)</span>
<span style="color: #00cd68;">}</span>
</pre>
</div>

<p>
Substitution is similarly defined by “walking” through the term,
but here, when we find variables, we choose whether to “replace them”
by the term being subbed in or not.
We have to adjust the variable being substituted and the
free variables in the term being subbed in according to
the number of variable binders we enter.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">In our usual syntax, we would write substitution as `t[x := r]`.</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Here we write `substitute(t,x,r)`.</span>
<span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">substitute</span><span style="color: #00cd68;">(</span>t<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ULTerm</span>, x<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Int</span>, r<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ULTerm</span><span style="color: #00cd68;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ULTerm</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00cd68;">{</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">We want to substitute for the free variable with number x.</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Inside a variable binder (abstraction),</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">the index of all free variables is shifted up by 1.</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">So we must keep track of the number of binders outside the current subterm.</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">walk</span><span style="color: #b6a0ff;">(</span>currentBinders<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Int</span>, t<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ULTerm</span><span style="color: #b6a0ff;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ULTerm</span> <span style="color: #b6a0ff;">=</span> t <span style="color: #b6a0ff;">match</span> <span style="color: #b6a0ff;">{</span>
    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">ULVar</span><span style="color: #6ae4b9;">(</span><span style="color: #00d3d0;">y</span><span style="color: #6ae4b9;">)</span> <span style="color: #b6a0ff;">if</span> y == x + currentBinders <span style="color: #b6a0ff;">=&gt;</span>
      <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">y is the xth free variable. Substitute for it,</span>
      <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">making sure to shift the free variables in r</span>
      <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">to account for the number of variable binders outside this subterm.</span>
      shift<span style="color: #6ae4b9;">(</span>currentBinders,r<span style="color: #6ae4b9;">)</span>
    
    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">ULVar</span><span style="color: #6ae4b9;">(</span><span style="color: #00d3d0;">y</span><span style="color: #6ae4b9;">)</span> <span style="color: #b6a0ff;">=&gt;</span>
      <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Otherwise, y is not the xth free variable;</span>
      <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">leave it as is.</span>
      <span style="color: #00bcff;">ULVar</span><span style="color: #6ae4b9;">(</span>y<span style="color: #6ae4b9;">)</span>
    
    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">ULAbs</span><span style="color: #6ae4b9;">(</span><span style="color: #00d3d0;">t</span><span style="color: #6ae4b9;">)</span> <span style="color: #b6a0ff;">=&gt;</span>
      <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">We now have one more variable binder outside the subterm.</span>
      <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Increment currentBinders and walk into the subterm.</span>
      <span style="color: #00bcff;">ULAbs</span><span style="color: #6ae4b9;">(</span>walk<span style="color: #f0ce43;">(</span>currentBinders+<span style="color: #00bcff;">1</span>,t<span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>

    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">ULApp</span><span style="color: #6ae4b9;">(</span><span style="color: #00d3d0;">t1</span>,<span style="color: #00d3d0;">t2</span><span style="color: #6ae4b9;">)</span> <span style="color: #b6a0ff;">=&gt;</span>
      <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">No new variable binders. Just walk into the subterms.</span>
      <span style="color: #00bcff;">ULApp</span><span style="color: #6ae4b9;">(</span>walk<span style="color: #f0ce43;">(</span>currentBinders,t1<span style="color: #f0ce43;">)</span>,walk<span style="color: #f0ce43;">(</span>currentBinders,t2<span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>
  <span style="color: #b6a0ff;">}</span>

  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Walk the term, performing the substitution.</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">We begin with 0 variable binders outside.</span>
  walk<span style="color: #b6a0ff;">(</span><span style="color: #00bcff;">0</span>,t<span style="color: #b6a0ff;">)</span>
<span style="color: #00cd68;">}</span>
</pre>
</div>

<p>
We need to check if terms are values for call-by-value semantics.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">We need to know if a term is a value during reduction</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">when using call-by-value semantics.</span>
<span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">isValue</span><span style="color: #00cd68;">(</span>t<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ULTerm</span><span style="color: #00cd68;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Boolean</span> <span style="color: #b6a0ff;">=</span> t <span style="color: #b6a0ff;">match</span> <span style="color: #00cd68;">{</span>
  <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">ULAbs</span><span style="color: #b6a0ff;">(</span><span style="color: #b6a0ff;">_</span><span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">true</span>
  <span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">false</span>
<span style="color: #00cd68;">}</span>
</pre>
</div>

<p>
Those semantics are given by a reduction function,
which reduces terms by one step, and then an evaluation function,
which keeps reducing until we get stuck (<i>if</i> we get stuck;
we might have an infinite reduction sequence.)
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Call-by-value reduction function.</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Performs one step of evaluation, if possible according to the call-by-value rules.</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">If no reduction is possible, returns None.</span>
<span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">reduce</span><span style="color: #00cd68;">(</span>t<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ULTerm</span><span style="color: #00cd68;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Option</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">ULTerm</span><span style="color: #00cd68;">]</span> <span style="color: #b6a0ff;">=</span> t <span style="color: #b6a0ff;">match</span> <span style="color: #00cd68;">{</span>

  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Case: the left term is an abstraction, and the right is a value.</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Then apply the value to the abstraction.</span>
  <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">ULApp</span><span style="color: #b6a0ff;">(</span><span style="color: #6ae4b9;">ULAbs</span><span style="color: #6ae4b9;">(</span><span style="color: #00d3d0;">t</span><span style="color: #6ae4b9;">)</span>,<span style="color: #00d3d0;">v</span><span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">if</span> isValue<span style="color: #b6a0ff;">(</span>v<span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">=&gt;</span>
    <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">When we apply the value to the abstraction,</span>
    <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">we must shift the value's free variables up by 1 to account</span>
    <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">for the abstraction's variable binder.</span>
    <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">r</span> <span style="color: #b6a0ff;">=</span> substitute<span style="color: #b6a0ff;">(</span>t,<span style="color: #00bcff;">0</span>,shift<span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">1</span>,v<span style="color: #6ae4b9;">)</span><span style="color: #b6a0ff;">)</span>
    <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Then, we need to shift the result back.</span>
    <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Since the abstraction's variable is now "used up".</span>
    <span style="color: #00bcff;">Some</span><span style="color: #b6a0ff;">(</span>shift<span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">-1</span>,r<span style="color: #6ae4b9;">)</span><span style="color: #b6a0ff;">)</span>

  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Case: the left term is a value, then try to reduce the right term.</span>
  <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">ULApp</span><span style="color: #b6a0ff;">(</span><span style="color: #00d3d0;">v</span>,<span style="color: #00d3d0;">t</span><span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">if</span> isValue<span style="color: #b6a0ff;">(</span>v<span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">=&gt;</span>
    reduce<span style="color: #b6a0ff;">(</span>t<span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">match</span> <span style="color: #b6a0ff;">{</span>
      <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Some</span><span style="color: #6ae4b9;">(</span><span style="color: #00d3d0;">r</span><span style="color: #6ae4b9;">)</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Some</span><span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">ULApp</span><span style="color: #f0ce43;">(</span>v,r<span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>
      <span style="color: #b6a0ff;">case</span> <span style="color: #00bcff;">None</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">None</span>
    <span style="color: #b6a0ff;">}</span>

  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Case: the left term is not a value (not an abstraction.)</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Try to reduce it.</span>
  <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">ULApp</span><span style="color: #b6a0ff;">(</span><span style="color: #00d3d0;">t1</span>,<span style="color: #00d3d0;">t2</span><span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">=&gt;</span>
    reduce<span style="color: #b6a0ff;">(</span>t1<span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">match</span> <span style="color: #b6a0ff;">{</span>
      <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Some</span><span style="color: #6ae4b9;">(</span><span style="color: #00d3d0;">r1</span><span style="color: #6ae4b9;">)</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Some</span><span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">ULApp</span><span style="color: #f0ce43;">(</span>r1,t2<span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>
      <span style="color: #b6a0ff;">case</span> <span style="color: #00bcff;">None</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">None</span>
    <span style="color: #b6a0ff;">}</span>
    
  <span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">None</span>
<span style="color: #00cd68;">}</span>

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Evaluation just repeatedly applies reduce,</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">until we reach None (signifying reduction failed.)</span>
<span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">evaluate</span><span style="color: #00cd68;">(</span>t<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ULTerm</span><span style="color: #00cd68;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ULTerm</span> <span style="color: #b6a0ff;">=</span> reduce<span style="color: #00cd68;">(</span>t<span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">match</span> <span style="color: #00cd68;">{</span>
  <span style="color: #b6a0ff;">case</span> <span style="color: #00bcff;">None</span> <span style="color: #b6a0ff;">=&gt;</span> t
  <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Some</span><span style="color: #b6a0ff;">(</span><span style="color: #00d3d0;">r</span><span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">=&gt;</span> evaluate<span style="color: #b6a0ff;">(</span>r<span style="color: #b6a0ff;">)</span>
<span style="color: #00cd68;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-Ruby-implementation" class="outline-3">
<h3 id="Ruby-implementation">Ruby implementation</h3>
<div class="outline-text-3" id="text-Ruby-implementation">
<p>
In Ruby, we use implement <i>UL</i> terms using a (super) class <code>ULTerm</code> with
subclasses for each kind of <i>UL</i> term.
</p>

<p>
The super class defines so default methods to keep track
of what kind of term we have.
These could be implemented as fields (instance variables),
but the use of methods implies that these values are constant
for all objects and across all time.
</p>
<div class="org-src-container">
<pre class="src src-ruby"><span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Our top-level ULTerm class defines some default</span>
<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">methods to track what kind of term we have</span>
<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">(which must be overidden in non-default cases)</span>
<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">as well as the shift, substitute and eval methods</span>
<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">which are defined in terms of other methods</span>
<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">defined by the subclasses.</span>
<span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">ULTerm</span>

  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">By default, we assume terms are irreducible,</span>
  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">not abstractions, and not values.</span>
  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Subclasses which should have these properties</span>
  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">must override these methods.</span>
  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">(In our basic calculus with call-by-value semantics,</span>
  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">only applications are reducible and only abstractions</span>
  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">are values. This can be changed for different calculi/semantics.)</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">reduce;</span> <span style="color: #00bcff;">nil</span> <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">absBody;</span> <span style="color: #00bcff;">nil</span> <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">isValue?;</span> <span style="color: #00bcff;">false</span> <span style="color: #b6a0ff;">end</span>
</pre>
</div>

<p>
We would not usually have enough information in this super <code>ULTerm</code> class
to be able to define the <code>shift</code> and <code>substitution</code> methods,
without resorting to (what I feel is) an ugly approach of using <code>is_a?</code> to check
whether the term is a variable, abstraction or application.
</p>

<p>
Previously, we used a local <code>walk</code> method inside of each of
the methods, which actually carried out the work on the terms.
We could do the same here, repeating the definition of <code>walk</code> inside of
the <code>shift</code> and <code>substitute</code> methods for each type of term
(at least, I believe we can do so.)
However, this repetition of code is very undesirable.
</p>

<p>
Instead, we take advantage of the fact that the <code>walk</code> method
was in fact <i>almost identical</i> for both shifting and substitution,
only acting differently on <i>variables</i>, to reimagine <code>walk</code> as
an iterator. This iterator will take as a block argument (a lambda)
the action to carry out on variables.
</p>

<p>
So, assuming that the <code>walk</code> method will be defined for each of the subclasses,
we can define <code>shift</code> and <code>substitute</code> here in the superclass
by writing the action to take on variables as a block,
and calling <code>walk</code> on the term with that action.
</p>
<div class="org-src-container">
<pre class="src src-ruby">  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Shifting is just walking, where in the base case,</span>
  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">we either increment the variable by shiftAmount or</span>
  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">leave it alone.</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">shift</span><span style="color: #00cd68;">(</span>shiftAmount<span style="color: #00cd68;">)</span>
    <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">walk is an iterator.</span>
    <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">The block tells us what to do with variables.</span>
    walk<span style="color: #00cd68;">(</span>0<span style="color: #00cd68;">)</span> <span style="color: #00cd68;">{</span> |x,currentBinders|
      <span style="color: #b6a0ff;">if</span> x &gt;= currentBinders
        <span style="color: #6ae4b9;">ULVar</span>.new<span style="color: #b6a0ff;">(</span>x+shiftAmount<span style="color: #b6a0ff;">)</span>
      <span style="color: #b6a0ff;">else</span>
        <span style="color: #6ae4b9;">ULVar</span>.new<span style="color: #b6a0ff;">(</span>x<span style="color: #b6a0ff;">)</span>
      <span style="color: #b6a0ff;">end</span> <span style="color: #00cd68;">}</span>
  <span style="color: #b6a0ff;">end</span>

  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Substitution is just walking, where we either</span>
  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">replace the variable, or leave it alone.</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">substitute</span><span style="color: #00cd68;">(</span>x,r<span style="color: #00cd68;">)</span>
    walk<span style="color: #00cd68;">(</span>0<span style="color: #00cd68;">)</span> <span style="color: #00cd68;">{</span> |y,currentBinders|
      <span style="color: #b6a0ff;">if</span> y == x + currentBinders
        r
      <span style="color: #b6a0ff;">else</span>
        <span style="color: #6ae4b9;">ULVar</span>.new<span style="color: #b6a0ff;">(</span>y<span style="color: #b6a0ff;">)</span>
      <span style="color: #b6a0ff;">end</span> <span style="color: #00cd68;">}</span>
  <span style="color: #b6a0ff;">end</span>
</pre>
</div>

<p>
Similarly to how we assume above that the <code>walk</code> method
will be defined for all subclasses, we also assume
that the <code>reduce</code> method will be defined for all subclasses,
since we lack a nice means to define it here.
However, we can easily define <code>eval</code> in terms of those <code>reduce</code> methods.
</p>
<div class="org-src-container">
<pre class="src src-ruby">  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">eval</span>
    r = <span style="color: #00bcff;">nil</span>
    r_next = <span style="color: #b6a0ff;">self</span>
    <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Keep reducing until it fails (reduce returns nil.)</span>
    <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">This is the recommended "do...while" form in Ruby.</span>
    <span style="color: #f78fe7;">loop</span> <span style="color: #b6a0ff;">do</span>
      r = r_next
      r_next = r.reduce
      <span style="color: #b6a0ff;">break</span> <span style="color: #b6a0ff;">unless</span> r_next
    <span style="color: #b6a0ff;">end</span>

    <span style="color: #b6a0ff;">return</span> r
  <span style="color: #b6a0ff;">end</span>
<span style="color: #b6a0ff;">end</span>
</pre>
</div>

<p>
As mentioned above, in each of the subclasses of <code>ULTerm</code>,
we need to define the <code>walk</code> and <code>reduce</code> methods.
But for variables, reduction is undefined, so we
do not define that method here.
(We do define here and below <code>to_s</code> methods, to allow
these terms to be printed somewhat nicely.)
</p>
<div class="org-src-container">
<pre class="src src-ruby"><span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">ULVar</span> &lt; <span style="color: #6ae4b9;">ULTerm</span>
  <span style="color: #f78fe7;">attr_reader</span> <span style="color: #00bcff;">:index</span>

  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">We require our variables are only indexed by integers.</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">initialize</span><span style="color: #00cd68;">(</span>i<span style="color: #00cd68;">)</span>
    <span style="color: #b6a0ff;">unless</span> i.is_a?<span style="color: #00cd68;">(</span><span style="color: #6ae4b9;">Integer</span><span style="color: #00cd68;">)</span>
      <span style="color: #f78fe7;">throw</span> <span style="color: #79a8ff;">"Constructing a lambda term out of non-lambda terms"</span>
    <span style="color: #b6a0ff;">end</span>
    <span style="color: #00d3d0;">@index</span> = i
  <span style="color: #b6a0ff;">end</span>
  
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">walk</span><span style="color: #00cd68;">(</span>currentBinders,&amp;block<span style="color: #00cd68;">)</span>
    <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">This is a variable. Run the code in &amp;block.</span>
    <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">(yield does this; it "yields" control to the block.)</span>
    <span style="color: #b6a0ff;">yield</span><span style="color: #00cd68;">(</span><span style="color: #00d3d0;">@index</span>, currentBinders<span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>

  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">to_s</span>
    <span style="color: #00d3d0;">@index</span>.to_s
  <span style="color: #b6a0ff;">end</span>

  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">==</span><span style="color: #00cd68;">(</span>r<span style="color: #00cd68;">)</span>; r.is_a?<span style="color: #00cd68;">(</span><span style="color: #6ae4b9;">ULVar</span><span style="color: #00cd68;">)</span> &amp;&amp; r.index == <span style="color: #00d3d0;">@index</span> <span style="color: #b6a0ff;">end</span>
<span style="color: #b6a0ff;">end</span>
</pre>
</div>

<p>
Again, we cannot <code>reduce</code> an abstraction,
so we do not define that method here.
But we do set override the <code>absBody</code> and <code>isValue?</code> methods
since this is an abstraction, and abstractions are values.
</p>
<div class="org-src-container">
<pre class="src src-ruby"><span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">ULAbs</span> &lt; <span style="color: #6ae4b9;">ULTerm</span>
  <span style="color: #f78fe7;">attr_reader</span> <span style="color: #00bcff;">:t</span>

  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">initialize</span><span style="color: #00cd68;">(</span>t<span style="color: #00cd68;">)</span>
    <span style="color: #b6a0ff;">unless</span> t.is_a?<span style="color: #00cd68;">(</span><span style="color: #6ae4b9;">ULTerm</span><span style="color: #00cd68;">)</span>
      <span style="color: #f78fe7;">throw</span> <span style="color: #79a8ff;">"Constructing a lambda term out of a non-lambda term"</span>
    <span style="color: #b6a0ff;">end</span>
    <span style="color: #00d3d0;">@t</span> = t
  <span style="color: #b6a0ff;">end</span>
  
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">walk</span><span style="color: #00cd68;">(</span>currentBinders,&amp;block<span style="color: #00cd68;">)</span>
    <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Increment the local variable counter within the variable binder.</span>
    t = <span style="color: #00d3d0;">@t</span>.walk<span style="color: #00cd68;">(</span>currentBinders+1,&amp;block<span style="color: #00cd68;">)</span>
    <span style="color: #6ae4b9;">ULAbs</span>.new<span style="color: #00cd68;">(</span>t<span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>

  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Abstractions are an abstraction (of course),</span>
  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">with body @t,</span>
  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">and are also considered values.</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">absBody;</span> <span style="color: #00d3d0;">@t</span> <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">isValue?;</span> <span style="color: #00bcff;">true</span> <span style="color: #b6a0ff;">end</span>
  
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">to_s</span>
    <span style="color: #79a8ff;">"lambda . "</span> + <span style="color: #00d3d0;">@t</span>.to_s
  <span style="color: #b6a0ff;">end</span>

  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">==</span><span style="color: #00cd68;">(</span>r<span style="color: #00cd68;">)</span>; r.is_a?<span style="color: #00cd68;">(</span><span style="color: #6ae4b9;">ULAbs</span><span style="color: #00cd68;">)</span> &amp;&amp; r.t == <span style="color: #00d3d0;">@t</span> <span style="color: #b6a0ff;">end</span>
<span style="color: #b6a0ff;">end</span>
</pre>
</div>

<p>
The application subclass is actually the only one
where we define the <code>reduce</code> method.
The logic of it is the same as in the Scala version,
though unfortunately the lack of pattern matching
makes it appear much worse.
(The source code was edited November 6th to remove some
diagnostic printing statements which were unfortunately included previously.)
</p>
<div class="org-src-container">
<pre class="src src-ruby"><span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">ULApp</span> &lt; <span style="color: #6ae4b9;">ULTerm</span>
  <span style="color: #f78fe7;">attr_reader</span> <span style="color: #00bcff;">:t1</span>
  <span style="color: #f78fe7;">attr_reader</span> <span style="color: #00bcff;">:t2</span>

  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">initialize</span><span style="color: #00cd68;">(</span>t1,t2<span style="color: #00cd68;">)</span>
    <span style="color: #b6a0ff;">unless</span> t1.is_a?<span style="color: #00cd68;">(</span><span style="color: #6ae4b9;">ULTerm</span><span style="color: #00cd68;">)</span> &amp;&amp; t2.is_a?<span style="color: #00cd68;">(</span><span style="color: #6ae4b9;">ULTerm</span><span style="color: #00cd68;">)</span>
      <span style="color: #f78fe7;">throw</span> <span style="color: #79a8ff;">"Constructing a lambda term out of non-lambda terms"</span>
    <span style="color: #b6a0ff;">end</span>
    <span style="color: #00d3d0;">@t1</span> = t1; <span style="color: #00d3d0;">@t2</span> = t2
  <span style="color: #b6a0ff;">end</span>
  
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">walk</span><span style="color: #00cd68;">(</span>currentBinders,&amp;block<span style="color: #00cd68;">)</span>
    t1 = <span style="color: #00d3d0;">@t1</span>.walk<span style="color: #00cd68;">(</span>currentBinders,&amp;block<span style="color: #00cd68;">)</span>
    t2 = <span style="color: #00d3d0;">@t2</span>.walk<span style="color: #00cd68;">(</span>currentBinders,&amp;block<span style="color: #00cd68;">)</span>
    <span style="color: #6ae4b9;">ULApp</span>.new<span style="color: #00cd68;">(</span>t1,t2<span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>

  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Applications can be reduced.</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">reduce</span>
    <span style="color: #b6a0ff;">if</span> <span style="color: #00d3d0;">@t1</span>.absBody &amp;&amp; <span style="color: #00d3d0;">@t2</span>.isValue?
      body = <span style="color: #00d3d0;">@t1</span>.absBody
      <span style="color: #00cd68;">(</span>body.substitute<span style="color: #b6a0ff;">(</span>0,<span style="color: #00d3d0;">@t2</span>.shift<span style="color: #6ae4b9;">(</span>1<span style="color: #6ae4b9;">)</span><span style="color: #b6a0ff;">)</span><span style="color: #00cd68;">)</span>.shift<span style="color: #00cd68;">(</span>-1<span style="color: #00cd68;">)</span>
    <span style="color: #b6a0ff;">elsif</span> <span style="color: #00d3d0;">@t1</span>.isValue?
      r = <span style="color: #00d3d0;">@t2</span>.reduce
      <span style="color: #b6a0ff;">if</span> r
        <span style="color: #6ae4b9;">ULApp</span>.new<span style="color: #00cd68;">(</span><span style="color: #00d3d0;">@t1</span>,r<span style="color: #00cd68;">)</span>
      <span style="color: #b6a0ff;">else</span>
        <span style="color: #00bcff;">nil</span>
      <span style="color: #b6a0ff;">end</span>
    <span style="color: #b6a0ff;">else</span>
      r = <span style="color: #00d3d0;">@t1</span>.reduce
      <span style="color: #b6a0ff;">if</span> r
        <span style="color: #6ae4b9;">ULApp</span>.new<span style="color: #00cd68;">(</span>r,<span style="color: #00d3d0;">@t2</span><span style="color: #00cd68;">)</span>
      <span style="color: #b6a0ff;">else</span>
        <span style="color: #00bcff;">nil</span>
      <span style="color: #b6a0ff;">end</span>
    <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">end</span>

  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">to_s</span>
    <span style="color: #79a8ff;">"("</span> + <span style="color: #00d3d0;">@t1</span>.to_s + <span style="color: #79a8ff;">") ("</span> + <span style="color: #00d3d0;">@t2</span>.to_s + <span style="color: #79a8ff;">")"</span> 
  <span style="color: #b6a0ff;">end</span>

  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">==</span><span style="color: #00cd68;">(</span>r<span style="color: #00cd68;">)</span>; r.is_a?<span style="color: #00cd68;">(</span><span style="color: #6ae4b9;">ULApp</span><span style="color: #00cd68;">)</span> &amp;&amp; r.t1 == <span style="color: #00d3d0;">@t1</span> &amp;&amp; r.t2 == <span style="color: #00d3d0;">@t2</span> <span style="color: #b6a0ff;">end</span>
<span style="color: #b6a0ff;">end</span>
</pre>
</div>

<p>
One important fact bears mentioning about our implementation
of <code>ULTerm</code> and its subclasses: note that all of the fields
of each class are read-only, and that their values
are only ever set in the constructors.
These are <i>value classes</i>; a <code>ULTerm</code> object is intended to be
(and will be, barring any misuse) <i>immutable</i> (unchanging over time.)
</p>

<p>
This design leads to better predictability of code;
there should never be an instance where a <code>ULTerm</code> changes unexpectedly
because of some method call, because <code>ULTerm</code>'s never change
after their creation.
</p>
</div>
</div>

<div id="outline-container-Examples-of-interacting-with-these-representations" class="outline-3">
<h3 id="Examples-of-interacting-with-these-representations">Examples of interacting with these representations</h3>
<div class="outline-text-3" id="text-Examples-of-interacting-with-these-representations">
<p>
The following code snippets show how you might use
these implementations to perform some simple computations.
</p>

<p>
In Scala:
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">The term "lambda x . lambda y . lambda z . u (x (y z))"</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Note the first variable (The one initialised with ULVar(3)) is free,</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">because it's index is greater than the number of abstractions</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">surrounding it.</span>
<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">x</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">ULAbs</span><span style="color: #00cd68;">(</span>
          <span style="color: #00bcff;">ULAbs</span><span style="color: #b6a0ff;">(</span>
            <span style="color: #00bcff;">ULAbs</span><span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">ULApp</span><span style="color: #f0ce43;">(</span><span style="color: #00bcff;">ULVar</span><span style="color: #00bcff;">(</span><span style="color: #00bcff;">3</span><span style="color: #00bcff;">)</span>,
                        <span style="color: #00bcff;">ULApp</span><span style="color: #00bcff;">(</span><span style="color: #00bcff;">ULVar</span><span style="color: #80d200;">(</span><span style="color: #00bcff;">2</span><span style="color: #80d200;">)</span>,
                              <span style="color: #00bcff;">ULApp</span><span style="color: #80d200;">(</span><span style="color: #00bcff;">ULVar</span><span style="color: #f78fe7;">(</span><span style="color: #00bcff;">1</span><span style="color: #f78fe7;">)</span>,
                                    <span style="color: #00bcff;">ULVar</span><span style="color: #f78fe7;">(</span><span style="color: #00bcff;">0</span><span style="color: #f78fe7;">)</span><span style="color: #80d200;">)</span><span style="color: #00bcff;">)</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span><span style="color: #b6a0ff;">)</span><span style="color: #00cd68;">)</span>
println<span style="color: #00cd68;">(</span><span style="color: #79a8ff;">"An unnamed representation of lambda x . lambda y . lambda z -&gt; u x y z:"</span><span style="color: #00cd68;">)</span>
print<span style="color: #00cd68;">(</span><span style="color: #79a8ff;">"</span><span style="color: #00bcff;">\t</span><span style="color: #79a8ff;">"</span><span style="color: #00cd68;">)</span>
println<span style="color: #00cd68;">(</span>x<span style="color: #00cd68;">)</span>

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Now substitute that term itself in for the free variable.</span>
println<span style="color: #00cd68;">(</span><span style="color: #79a8ff;">"The result of substituting that term into itself for the variable u:"</span><span style="color: #00cd68;">)</span>
print<span style="color: #00cd68;">(</span><span style="color: #79a8ff;">"</span><span style="color: #00bcff;">\t</span><span style="color: #79a8ff;">"</span><span style="color: #00cd68;">)</span>
println<span style="color: #00cd68;">(</span>substitute<span style="color: #b6a0ff;">(</span>x,<span style="color: #00bcff;">0</span>,x<span style="color: #b6a0ff;">)</span><span style="color: #00cd68;">)</span>
</pre>
</div>

<p>
And in Ruby:
</p>
<div class="org-src-container">
<pre class="src src-ruby"><span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">The term "lambda x . lambda y . lambda z . u (x (y z))"</span>
<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Note the first variable (The one initialised with ULVar.new(3)) is free,</span>
<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">because it's index is greater than the number of abstractions</span>
<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">surrounding it.</span>
x = <span style="color: #6ae4b9;">ULAbs</span>.new<span style="color: #00cd68;">(</span>
      <span style="color: #6ae4b9;">ULAbs</span>.new<span style="color: #b6a0ff;">(</span>
        <span style="color: #6ae4b9;">ULAbs</span>.new<span style="color: #6ae4b9;">(</span><span style="color: #6ae4b9;">ULApp</span>.new<span style="color: #f0ce43;">(</span><span style="color: #6ae4b9;">ULVar</span>.new<span style="color: #00bcff;">(</span>3<span style="color: #00bcff;">)</span>,
                            <span style="color: #6ae4b9;">ULApp</span>.new<span style="color: #00bcff;">(</span><span style="color: #6ae4b9;">ULVar</span>.new<span style="color: #80d200;">(</span>2<span style="color: #80d200;">)</span>,
                                      <span style="color: #6ae4b9;">ULApp</span>.new<span style="color: #80d200;">(</span><span style="color: #6ae4b9;">ULVar</span>.new<span style="color: #f78fe7;">(</span>1<span style="color: #f78fe7;">)</span>,
                                                <span style="color: #6ae4b9;">ULVar</span>.new<span style="color: #f78fe7;">(</span>0<span style="color: #f78fe7;">)</span><span style="color: #80d200;">)</span><span style="color: #00bcff;">)</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span><span style="color: #b6a0ff;">)</span><span style="color: #00cd68;">)</span>
<span style="color: #f78fe7;">puts</span> <span style="color: #79a8ff;">"An unnamed representation of lambda x . lambda y . lambda z -&gt; u x y z:"</span>
<span style="color: #f78fe7;">print</span> <span style="color: #79a8ff;">"\t"</span>
<span style="color: #f78fe7;">puts</span> x

<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Now substitute that term itself in for the free variable.</span>
<span style="color: #f78fe7;">puts</span> <span style="color: #79a8ff;">"The result of substituting that term into itself for the variable u:"</span>
<span style="color: #f78fe7;">print</span> <span style="color: #79a8ff;">"\t"</span>
<span style="color: #f78fe7;">puts</span> x.substitute<span style="color: #00cd68;">(</span>0,x<span style="color: #00cd68;">)</span>

<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Note that the term itself remains unchanged;</span>
<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">we've made sure this type is immutable</span>
<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">by always creating new terms, or reusing them if that's not necessary,</span>
<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">in the class methods. The fields are only ever changed in the constructors.</span>
<span style="color: #f78fe7;">puts</span> x
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-Part-1-–-The-representation----------------------------------[10 marks]" class="outline-2">
<h2 id="Part-1-–-The-representation----------------------------------[10 marks]">Part 1 – The representation                                  [10 marks]</h2>
<div class="outline-text-2" id="text-Part-1-–-The-representation----------------------------------[10 marks]">
<div class="org-center">
<p>
<b>Place your code for this part in the files <code>a2.sc</code> and <code>a2.rb</code>.</b>
</p>
</div>

<p>
Implement, in both Scala and Ruby,
a type <code>STTerm</code> to represent terms of the λ-calculus <i>ST</i> defined above.
</p>

<p>
The constructors of the type should be named
</p>
<ul class="org-ul">
<li><code>STVar</code>,</li>
<li><code>STApp</code>,</li>
<li><code>STAbs</code>,</li>
<li><code>STZero</code>,</li>
<li><code>STSuc</code>,</li>
<li><code>STIsZero</code>,</li>
<li><code>STTrue</code>,</li>
<li><code>STFalse</code>, and</li>
<li><code>STTest</code>.</li>
</ul>

<p>
(The remaining text of this section was added November 10th.)
</p>

<p>
The <code>STZero</code>, <code>STTrue</code> and <code>STFalse</code> types should be declared as
singleton classes in Scala (i.e., as <code>case object</code>'s instead of <code>case class</code>'s.)
</p>

<p>
Note that the <code>STAbs</code> constructor must take an argument specifying
the <i>type</i> of the variable being abstracted. This argument
should be of the following types.
(This code should be included in your <code>a2</code> file.)
In <a href="./src/a2_types.sc">Scala</a>:
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #f78fe7;">sealed</span> <span style="color: #b6a0ff;">trait</span> <span style="color: #6ae4b9;">STType</span>
<span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">object</span> <span style="color: #00bcff;">STNat</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #6ae4b9;">STType</span> <span style="color: #00cd68;">{</span>
  <span style="color: #f78fe7;">override</span> <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">toString</span><span style="color: #b6a0ff;">()</span> <span style="color: #b6a0ff;">=</span> <span style="color: #79a8ff;">"nat"</span>
<span style="color: #00cd68;">}</span>
<span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">object</span> <span style="color: #00bcff;">STBool</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #6ae4b9;">STType</span> <span style="color: #00cd68;">{</span>
  <span style="color: #f78fe7;">override</span> <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">toString</span><span style="color: #b6a0ff;">()</span> <span style="color: #b6a0ff;">=</span> <span style="color: #79a8ff;">"bool"</span>
<span style="color: #00cd68;">}</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Functions have a domain type and a codomain type.</span>
<span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">STFun</span><span style="color: #00cd68;">(</span>dom<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">STType</span>, codom<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">STType</span><span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #6ae4b9;">STType</span> <span style="color: #00cd68;">{</span>
  <span style="color: #f78fe7;">override</span> <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">toString</span><span style="color: #b6a0ff;">()</span> <span style="color: #b6a0ff;">=</span> <span style="color: #79a8ff;">"("</span> + dom.toString + <span style="color: #79a8ff;">") -&gt; ("</span> + codom.toString + <span style="color: #79a8ff;">")"</span>
<span style="color: #00cd68;">}</span>

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Example use: the type "nat -&gt; bool" is written STFun(STNat,STBool)</span>
</pre>
</div>
<p>
And in <a href="./src/a2_types.rb">Ruby</a>:
</p>
<div class="org-src-container">
<pre class="src src-ruby"><span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">STType</span> <span style="color: #b6a0ff;">end</span>

<span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">STNat</span> &lt; <span style="color: #6ae4b9;">STType</span>
  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Comparison and printing methods</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">==</span><span style="color: #00cd68;">(</span>type<span style="color: #00cd68;">)</span>; type.is_a?<span style="color: #00cd68;">(</span><span style="color: #6ae4b9;">STNat</span><span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">to_s;</span> <span style="color: #79a8ff;">"nat"</span> <span style="color: #b6a0ff;">end</span>
<span style="color: #b6a0ff;">end</span>

<span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">STBool</span> &lt; <span style="color: #6ae4b9;">STType</span>
  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Comparison and printing methods</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">==</span><span style="color: #00cd68;">(</span>type<span style="color: #00cd68;">)</span>; type.is_a?<span style="color: #00cd68;">(</span><span style="color: #6ae4b9;">STBool</span><span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">to_s;</span> <span style="color: #79a8ff;">"bool"</span> <span style="color: #b6a0ff;">end</span>
<span style="color: #b6a0ff;">end</span>

<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Functions have a domain type and a codomain type.</span>
<span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">STFun</span> &lt; <span style="color: #6ae4b9;">STType</span>
  <span style="color: #f78fe7;">attr_reader</span> <span style="color: #00bcff;">:dom</span>
  <span style="color: #f78fe7;">attr_reader</span> <span style="color: #00bcff;">:codom</span>
  
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">initialize</span><span style="color: #00cd68;">(</span>dom, codom<span style="color: #00cd68;">)</span>
    <span style="color: #b6a0ff;">unless</span> dom.is_a?<span style="color: #00cd68;">(</span><span style="color: #6ae4b9;">STType</span><span style="color: #00cd68;">)</span> &amp;&amp; dom.is_a?<span style="color: #00cd68;">(</span><span style="color: #6ae4b9;">STType</span><span style="color: #00cd68;">)</span>
      <span style="color: #f78fe7;">throw</span> <span style="color: #79a8ff;">"Constructing a type out of non-types"</span>
    <span style="color: #b6a0ff;">end</span>
    <span style="color: #00d3d0;">@dom</span> = dom; <span style="color: #00d3d0;">@codom</span> = codom
  <span style="color: #b6a0ff;">end</span>

  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Comparison and printing methods</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">==</span><span style="color: #00cd68;">(</span>type<span style="color: #00cd68;">)</span>; type.is_a?<span style="color: #00cd68;">(</span><span style="color: #6ae4b9;">STFun</span><span style="color: #00cd68;">)</span> &amp;&amp; type.dom == <span style="color: #00d3d0;">@dom</span> &amp;&amp; type.codom == <span style="color: #00d3d0;">@codom</span> <span style="color: #b6a0ff;">end</span> 
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">to_s;</span> <span style="color: #79a8ff;">"("</span> + dom.to_s + <span style="color: #79a8ff;">") -&gt; ("</span> + codom.to_s + <span style="color: #79a8ff;">")"</span> <span style="color: #b6a0ff;">end</span>
<span style="color: #b6a0ff;">end</span>

<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Example use: the type "nat -&gt; bool" is written STFun.new(STNat.new,STBool.new)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-Part-1-–-Interpreter-written-in-Scala--[20 marks]" class="outline-2">
<h2 id="Part-1-–-Interpreter-written-in-Scala--[20 marks]">Part 2 – Type checking                                       [40 marks]</h2>
<div class="outline-text-2" id="text-Part-1-–-Interpreter-written-in-Scala--[20 marks]">
<div class="org-center">
<p>
<b>Place your code for this part in the files <code>a2.sc</code> and <code>a2.rb</code>.</b>
</p>
</div>

<p>
Implement, in both Scala and Ruby,
a <i>type checker</i> method named <code>typecheck</code> for elements of <code>STTerm</code>.
</p>

<p>
This <code>typecheck</code> method takes an <code>STTerm</code>, and returns <code>true</code> if
the represented term obeys the type rules of <i>ST</i>;
otherwise, it returns <code>false</code>.
</p>

<p>
(The remaining text of this section was added November 10th.)
</p>

<p>
The definition of <code>typecheck</code> will require a method to determine
the type of a given expression.
The name <code>typeOf</code> is recommended for this method.
This method should have as an argument the <i>environment</i>;
i.e., a map, list or similar type which relates variables to types. 
(Since variables are represented as integers,
this means relating integers to <code>STType</code> values.)
</p>

<p>
I (Mark) <i>suggest</i> that <code>typeOf</code> method return a <code>Option[STType]</code> in the Scala implementation,
but this is not a requirement.
You will not be penalised for using any reasonable implementation,
including
</p>
<ul class="org-ul">
<li>use of exceptions when a term has no type,</li>
<li>use of the <code>Try</code>, <code>Success</code> and <code>Failure</code> types, or</li>
<li>use of the <code>Either</code> type.</li>
</ul>
<p>
If you have another implementation in mind, you are welcome to check
with Mark.
</p>
</div>
</div>

<div id="outline-container-Part-2-–-Interpreter-written-in-Prolog-[20 marks]" class="outline-2">
<h2 id="Part-2-–-Interpreter-written-in-Prolog-[20 marks]">Part 3 – Translation to the untyped λ-calculus; type erasure [40 marks]</h2>
<div class="outline-text-2" id="text-Part-2-–-Interpreter-written-in-Prolog-[20 marks]">
<div class="org-center">
<p>
<b>Place your code for this part in the files <code>a2.sc</code> and <code>a2.rb</code>.</b>
</p>
</div>

<p>
Implement, in both Scala and Ruby,
a method <code>eraseTypes</code> for elements of <code>STTerm</code>,
which <i>translates</i> them into elements of <code>ULTerm</code> (definition given above.)
</p>

<p>
This translation also needs to translate the natural and boolean constants
into the pure λ-calculus encodings that represent them.
Recall these translations from the notes (the translation for <code>iszero</code> has been added.)
</p>
<div class="org-src-container">
<pre class="src src-text">true   = &#955; t &#8594; &#955; f &#8594; t
false  = &#955; t &#8594; &#955; f &#8594; f
test   = &#955; l &#8594; &#955; m &#8594; &#955; n &#8594; l m n
zero   = &#955; s &#8594; &#955; z &#8594; z
suc    = &#955; n &#8594; &#955; s &#8594; &#955; z &#8594; s <span style="color: #00cd68;">(</span>n s z<span style="color: #00cd68;">)</span>
iszero = &#955; m &#8594; m <span style="color: #00cd68;">(</span>&#955; x &#8594; false<span style="color: #00cd68;">)</span> true     
</pre>
</div>
<p>
Bear in mind that application is left-associative, so, e.g., <code>l m n</code> is
equivalent to <code>(l m) n</code>.
</p>

<p>
(You should import the <code>a2_ulterm</code> files into your file
in a manner compatible with the Docker testing environments,
or copy the definitions into your file and create
blank <code>a2_ulterm</code> files to satisfy the import statements in the testing.)
</p>
</div>
</div>

<div id="outline-container-Part-4-–-Bonus:-Interpreting-/SL/-programs---------------------[10 marks]" class="outline-2">
<h2 id="Part-4-–-Bonus:-Interpreting-/SL/-programs---------------------[10 marks]">Part 4 – Bonus: Interpreting <i>SL</i> programs                     [10 marks]</h2>
<div class="outline-text-2" id="text-Part-4-–-Bonus:-Interpreting-/SL/-programs---------------------[10 marks]">
<div class="org-center">
<p>
<b>Place any code for this part in files <code>a2p4.sc</code> and <code>a2p4.rb</code>.</b>
</p>
</div>

<p>
Implement an evaluation method for your <code>STTerm</code> type.
</p>

<p>
Make use of the evaluation method for <code>ULTerm</code>'s in your definition.
You will also need a method to convert results back
to an <code>STTerm</code> representation.
</p>
</div>
</div>

<div id="outline-container-Part-5-–-Bonus:-pairs----------------------------------------[10 bonus marks]" class="outline-2">
<h2 id="Part-5-–-Bonus:-pairs----------------------------------------[10 bonus marks]">Part 5 – Bonus: pairs                                        [10 bonus marks]</h2>
<div class="outline-text-2" id="text-Part-5-–-Bonus:-pairs----------------------------------------[10 bonus marks]">
<div class="org-center">
<p>
<b>Place any code for this part in files <code>a2p5.sc</code> and <code>a2p5.rb</code>.</b>
</p>
</div>

<p>
Implement another λ-calculus, called <i>ST2</i>, which includes
the type of <i>pairs</i> as well as naturals and booleans,
along with a type checker, type eraser and evaluation method.
</p>
</div>
</div>

<div id="outline-container-Submission-checklist" class="outline-2">
<h2 id="Submission-checklist">Submission checklist</h2>
<div class="outline-text-2" id="text-Submission-checklist">
<p>
For your convenience, this checklist is provided
to track the files you need to submit.
Use it if you wish.
</p>
<div class="org-src-container">
<pre class="src src-text">- <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> Documentation; one of
  - <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> README.html
  - <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> README.pdf
  - <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> README.md
  - <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> README.org
- <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> Code files
  - <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> a2.sc
  - <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> a2.rb
- <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> Part 2 tests
  - <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> a2p2_test.sc tests have passed! <span style="color: #00cd68;">(</span>No submission needed.<span style="color: #00cd68;">)</span>
  - <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> a2p2_test.rb tests have passed! <span style="color: #00cd68;">(</span>No submission needed.<span style="color: #00cd68;">)</span>
- <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> Part 3 tests
  - <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> a2p3_test.sc tests have passed! <span style="color: #00cd68;">(</span>No submission needed.<span style="color: #00cd68;">)</span>
  - <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> a2p3_test.rb tests have passed! <span style="color: #00cd68;">(</span>No submission needed.<span style="color: #00cd68;">)</span>
- <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> Part 4 <span style="color: #00cd68;">(</span>Bonus<span style="color: #00cd68;">)</span>
  - <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> a2p4.sc
  - <span style="color: #00cd68;">[</span> <span style="color: #00cd68;">]</span> a2p4.rb
</pre>
</div>
</div>
</div>

<div id="outline-container-Testing" class="outline-2">
<h2 id="Testing">Testing</h2>
<div class="outline-text-2" id="text-Testing">
<p>
Unit tests for the requested types, methods and predicates
are available here.
</p>
<ul class="org-ul">
<li><a href="./testing/a1/a1p1_test.sc">a2_test.sc</a></li>
<li><a href="./testing/a1/a1p2.plt">a2_test.rb</a></li>
</ul>
<p>
The contents of the unit test files are also repeated below.
</p>

<p>
The tests can be run by placing the test files
in the same directory as your code files.
</p>

<p>
To run the tests for the Scala portions, use the command
</p>
<div class="org-src-container">
<pre class="src src-shell">amm a2_test.sc
</pre>
</div>

<p>
To run the tests for the Ruby portions,us the commands
</p>
<div class="org-src-container">
<pre class="src src-shell">ruby a2_test.rb
</pre>
</div>

<div class="org-center">
<p>
<b>You are strongly encouraged to add your own additional test cases</b>
<b>to those provided for you.</b>
</p>

<p>
The provided test cases check a very minimal amount!
</p>
</div>
</div>

<div id="outline-container-Automated-testing-via-Docker" class="outline-3">
<h3 id="Automated-testing-via-Docker">Automated testing via Docker</h3>
<div class="outline-text-3" id="text-Automated-testing-via-Docker">
<p>
The Docker setup and usage scripts are available at the following links.
Their contents are also repeated below.
</p>
<ul class="org-ul">
<li><a href="./testing/a2/Dockerfile">Dockerfile</a></li>
<li><a href="./testing/a2/docker-compose.yml">docker-compose.yml</a></li>
<li><a href="./testing/a2/setup.sh">setup.sh</a></li>
<li><a href="./testing/a2/run.sh">run.sh</a></li>
</ul>
<p>
Place them into your <code>a2</code> directory where your code files
and the test files (linked to above) exist,
then run <code>setup.sh</code> and <code>run.sh</code>.
</p>

<p>
Note that the use of the <code>setup.sh</code> and <code>run.sh</code> scripts assumes
that you are in a <code>bash</code> like shell; if you are on Windows,
and not using WSL or WSL2, you may have
to run the commands contained in those scripts manually.
</p>
</div>
</div>

<div id="outline-container-The-tests" class="outline-3">
<h3 id="The-tests">The tests</h3>
<div class="outline-text-3" id="text-The-tests">
</div>

<div id="outline-container-Scala" class="outline-4">
<h4 id="Scala">Scala</h4>
<div class="outline-text-4" id="text-Scala">
<p>
<a href="./testing/a2/a2_testframework.sc">a2_test.sc</a>
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #b6a0ff;">import</span> $file.a2, a2.<span style="color: #b6a0ff;">_</span>
<span style="color: #b6a0ff;">import</span> $file.a2_ulterm, a2_ulterm.<span style="color: #b6a0ff;">_</span>

<span style="color: #a8a8a8;">/* </span><span style="color: #a8a8a8;">Given an expected result and a computed result,</span>
<span style="color: #a8a8a8;">   check if they are equal in value.</span>
<span style="color: #a8a8a8;">   If so, return 0. Otherwise, inform the user, and return 1,</span>
<span style="color: #a8a8a8;">   so the number of failures can be counted. */</span>
<span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">test</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>given<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">A</span>, expected<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">A</span>, the_test<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">String</span><span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">=</span>
  <span style="color: #b6a0ff;">if</span> <span style="color: #00cd68;">(</span>!<span style="color: #b6a0ff;">(</span>given equals expected<span style="color: #b6a0ff;">)</span><span style="color: #00cd68;">)</span> <span style="color: #00cd68;">{</span>
    println<span style="color: #b6a0ff;">(</span><span style="color: #79a8ff;">"+---------------------------------------------------"</span><span style="color: #b6a0ff;">)</span>
    println<span style="color: #b6a0ff;">(</span><span style="color: #79a8ff;">"| "</span> + the_test + <span style="color: #79a8ff;">" failed."</span><span style="color: #b6a0ff;">)</span>
    println<span style="color: #b6a0ff;">(</span><span style="color: #79a8ff;">"| Expected "</span> + expected + <span style="color: #79a8ff;">", got "</span> + given + <span style="color: #79a8ff;">"."</span><span style="color: #b6a0ff;">)</span>
    println<span style="color: #b6a0ff;">(</span><span style="color: #79a8ff;">"+---------------------------------------------------"</span><span style="color: #b6a0ff;">)</span>
    <span style="color: #00bcff;">1</span>
  <span style="color: #00cd68;">}</span> <span style="color: #b6a0ff;">else</span> <span style="color: #00cd68;">{</span>
    <span style="color: #00bcff;">0</span>
  <span style="color: #00cd68;">}</span>

<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">providedTests</span> <span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">List</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">Tuple3</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">Unit</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Any</span>, <span style="color: #00bcff;">Any</span>, <span style="color: #00bcff;">String</span><span style="color: #b6a0ff;">]</span><span style="color: #00cd68;">]</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">List</span><span style="color: #00cd68;">(</span>

  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Positive typechecking test cases</span>
  <span style="color: #b6a0ff;">(</span><span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> typecheck<span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">STZero</span><span style="color: #6ae4b9;">)</span>,                       <span style="color: #00bcff;">true</span>, <span style="color: #79a8ff;">"Typecheck zero"</span><span style="color: #b6a0ff;">)</span>,
  <span style="color: #b6a0ff;">(</span><span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> typecheck<span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">STSuc</span><span style="color: #f0ce43;">(</span><span style="color: #00bcff;">STZero</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>,                <span style="color: #00bcff;">true</span>, <span style="color: #79a8ff;">"Typecheck one"</span><span style="color: #b6a0ff;">)</span>,
  <span style="color: #b6a0ff;">(</span><span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> typecheck<span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">STIsZero</span><span style="color: #f0ce43;">(</span><span style="color: #00bcff;">STZero</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>,             <span style="color: #00bcff;">true</span>, <span style="color: #79a8ff;">"Typecheck iszero zero"</span><span style="color: #b6a0ff;">)</span>,
  <span style="color: #b6a0ff;">(</span><span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> typecheck<span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">STTrue</span><span style="color: #6ae4b9;">)</span>,                       <span style="color: #00bcff;">true</span>, <span style="color: #79a8ff;">"Typecheck true"</span><span style="color: #b6a0ff;">)</span>,
  <span style="color: #b6a0ff;">(</span><span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> typecheck<span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">STFalse</span><span style="color: #6ae4b9;">)</span>,                      <span style="color: #00bcff;">true</span>, <span style="color: #79a8ff;">"Typecheck false"</span><span style="color: #b6a0ff;">)</span>,
  <span style="color: #b6a0ff;">(</span><span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> typecheck<span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">STTest</span><span style="color: #f0ce43;">(</span><span style="color: #00bcff;">STTrue</span>,<span style="color: #00bcff;">STZero</span>,<span style="color: #00bcff;">STZero</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>, <span style="color: #00bcff;">true</span>, <span style="color: #79a8ff;">"Typecheck test true zero zero"</span><span style="color: #b6a0ff;">)</span>,
  <span style="color: #b6a0ff;">(</span><span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> typecheck<span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">STAbs</span><span style="color: #f0ce43;">(</span><span style="color: #00bcff;">STNat</span>,<span style="color: #00bcff;">STVar</span><span style="color: #00bcff;">(</span><span style="color: #00bcff;">0</span><span style="color: #00bcff;">)</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>,        <span style="color: #00bcff;">true</span>, <span style="color: #79a8ff;">"Typecheck lambda x : nat . x"</span><span style="color: #b6a0ff;">)</span>,
  <span style="color: #b6a0ff;">(</span><span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> typecheck<span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">STApp</span><span style="color: #f0ce43;">(</span><span style="color: #00bcff;">STAbs</span><span style="color: #00bcff;">(</span><span style="color: #00bcff;">STNat</span>,<span style="color: #00bcff;">STVar</span><span style="color: #80d200;">(</span><span style="color: #00bcff;">0</span><span style="color: #80d200;">)</span><span style="color: #00bcff;">)</span>,<span style="color: #00bcff;">STZero</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>, <span style="color: #00bcff;">true</span>, <span style="color: #79a8ff;">"Typecheck (lambda x : nat . x) (zero)"</span><span style="color: #b6a0ff;">)</span>,

  
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Negative typechecking test cases</span>
  <span style="color: #b6a0ff;">(</span><span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> typecheck<span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">STSuc</span><span style="color: #f0ce43;">(</span><span style="color: #00bcff;">STFalse</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>, <span style="color: #00bcff;">false</span>,
    <span style="color: #79a8ff;">"Successor of false should not typecheck."</span><span style="color: #b6a0ff;">)</span>,
  <span style="color: #b6a0ff;">(</span><span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> typecheck<span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">STVar</span><span style="color: #f0ce43;">(</span><span style="color: #00bcff;">0</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>, <span style="color: #00bcff;">false</span>,
    <span style="color: #79a8ff;">"Free variables should not typecheck"</span><span style="color: #b6a0ff;">)</span>,
  <span style="color: #b6a0ff;">(</span><span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> typecheck<span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">STApp</span><span style="color: #f0ce43;">(</span><span style="color: #00bcff;">STAbs</span><span style="color: #00bcff;">(</span><span style="color: #00bcff;">STNat</span>,<span style="color: #00bcff;">STVar</span><span style="color: #80d200;">(</span><span style="color: #00bcff;">0</span><span style="color: #80d200;">)</span><span style="color: #00bcff;">)</span>,<span style="color: #00bcff;">STFalse</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>, <span style="color: #00bcff;">false</span>,
    <span style="color: #79a8ff;">"Applying a boolean to a natural function should not typecheck"</span><span style="color: #b6a0ff;">)</span>,

  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Type erasure tests</span>
  <span style="color: #b6a0ff;">(</span><span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> eraseTypes<span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">STTrue</span><span style="color: #6ae4b9;">)</span>, <span style="color: #00bcff;">ULAbs</span><span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">ULAbs</span><span style="color: #f0ce43;">(</span><span style="color: #00bcff;">ULVar</span><span style="color: #00bcff;">(</span><span style="color: #00bcff;">1</span><span style="color: #00bcff;">)</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>, <span style="color: #79a8ff;">"Erase types of true"</span><span style="color: #b6a0ff;">)</span>,
  <span style="color: #b6a0ff;">(</span><span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> eraseTypes<span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">STSuc</span><span style="color: #f0ce43;">(</span><span style="color: #00bcff;">STZero</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>,
    <span style="color: #00bcff;">ULApp</span><span style="color: #6ae4b9;">(</span>
      <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Encoding of suc</span>
      <span style="color: #00bcff;">ULAbs</span><span style="color: #f0ce43;">(</span> <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">lambda n .</span>
        <span style="color: #00bcff;">ULAbs</span><span style="color: #00bcff;">(</span> <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">lambda s.</span>
          <span style="color: #00bcff;">ULAbs</span><span style="color: #80d200;">(</span> <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">lambda z.</span>
            <span style="color: #00bcff;">ULApp</span><span style="color: #f78fe7;">(</span><span style="color: #00bcff;">ULVar</span><span style="color: #4ae8fc;">(</span><span style="color: #00bcff;">1</span><span style="color: #4ae8fc;">)</span>,<span style="color: #00bcff;">ULApp</span><span style="color: #4ae8fc;">(</span><span style="color: #00bcff;">ULApp</span><span style="color: #cfdf30;">(</span><span style="color: #00bcff;">ULVar</span><span style="color: #00cd68;">(</span><span style="color: #00bcff;">2</span><span style="color: #00cd68;">)</span>,<span style="color: #00bcff;">ULVar</span><span style="color: #00cd68;">(</span><span style="color: #00bcff;">1</span><span style="color: #00cd68;">)</span><span style="color: #cfdf30;">)</span>,<span style="color: #00bcff;">ULVar</span><span style="color: #cfdf30;">(</span><span style="color: #00bcff;">0</span><span style="color: #cfdf30;">)</span><span style="color: #4ae8fc;">)</span><span style="color: #f78fe7;">)</span><span style="color: #80d200;">)</span><span style="color: #00bcff;">)</span><span style="color: #f0ce43;">)</span>, <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">s (n s z)</span>
      <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Encoding of zero</span>
      <span style="color: #00bcff;">ULAbs</span><span style="color: #f0ce43;">(</span> <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">lambda s .</span>
        <span style="color: #00bcff;">ULAbs</span><span style="color: #00bcff;">(</span> <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">lambda z .</span>
          <span style="color: #00bcff;">ULVar</span><span style="color: #80d200;">(</span><span style="color: #00bcff;">0</span><span style="color: #80d200;">)</span><span style="color: #00bcff;">)</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>, <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">z</span>
    <span style="color: #79a8ff;">"Erase types of one"</span><span style="color: #b6a0ff;">)</span>,
  <span style="color: #b6a0ff;">(</span><span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> eraseTypes<span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">STApp</span><span style="color: #f0ce43;">(</span><span style="color: #00bcff;">STAbs</span><span style="color: #00bcff;">(</span><span style="color: #00bcff;">STNat</span>,<span style="color: #00bcff;">STVar</span><span style="color: #80d200;">(</span><span style="color: #00bcff;">0</span><span style="color: #80d200;">)</span><span style="color: #00bcff;">)</span>,<span style="color: #00bcff;">STZero</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>,
    <span style="color: #00bcff;">ULApp</span><span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">ULAbs</span><span style="color: #f0ce43;">(</span><span style="color: #00bcff;">ULVar</span><span style="color: #00bcff;">(</span><span style="color: #00bcff;">0</span><span style="color: #00bcff;">)</span><span style="color: #f0ce43;">)</span>, <span style="color: #00bcff;">ULAbs</span><span style="color: #f0ce43;">(</span><span style="color: #00bcff;">ULAbs</span><span style="color: #00bcff;">(</span><span style="color: #00bcff;">ULVar</span><span style="color: #80d200;">(</span><span style="color: #00bcff;">0</span><span style="color: #80d200;">)</span><span style="color: #00bcff;">)</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>,
    <span style="color: #79a8ff;">"Erase types of (lambda x : nat . x) (zero)"</span><span style="color: #b6a0ff;">)</span>,
<span style="color: #00cd68;">)</span>

<span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">runTests</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>tests<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">List</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">Tuple3</span><span style="color: #6ae4b9;">[</span><span style="color: #00bcff;">Unit</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">A</span>,<span style="color: #00bcff;">A</span>,<span style="color: #00bcff;">String</span><span style="color: #6ae4b9;">]</span><span style="color: #b6a0ff;">]</span><span style="color: #00cd68;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Unit</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00cd68;">{</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Apply test to each element of tests, and sum the return values.</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">This is essentially a for loop.</span>
  <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">failed</span> <span style="color: #b6a0ff;">=</span> tests.foldLeft<span style="color: #b6a0ff;">(</span><span style="color: #00bcff;">0</span><span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">{</span>
    <span style="color: #6ae4b9;">(</span>failures, next<span style="color: #6ae4b9;">)</span> <span style="color: #b6a0ff;">=&gt;</span> next <span style="color: #b6a0ff;">match</span> <span style="color: #6ae4b9;">{</span>
      <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Deconstruct the tuple to get its parts</span>
      <span style="color: #b6a0ff;">case</span> <span style="color: #f0ce43;">(</span><span style="color: #00d3d0;">given</span>, <span style="color: #00d3d0;">expected</span>, <span style="color: #00d3d0;">the_test</span><span style="color: #f0ce43;">)</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #f0ce43;">{</span>
        <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">failure</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">try</span> <span style="color: #00bcff;">{</span>
          test<span style="color: #80d200;">(</span>given<span style="color: #f78fe7;">()</span>, expected, the_test<span style="color: #80d200;">)</span>
        <span style="color: #00bcff;">}</span> <span style="color: #b6a0ff;">catch</span> <span style="color: #00bcff;">{</span>
          <span style="color: #b6a0ff;">case</span> <span style="color: #00d3d0;">e</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exception</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #80d200;">{</span>
            print<span style="color: #f78fe7;">(</span><span style="color: #79a8ff;">"Test "</span> + the_test + <span style="color: #79a8ff;">"encountered exception: "</span><span style="color: #f78fe7;">)</span>
            println<span style="color: #f78fe7;">(</span>e<span style="color: #f78fe7;">)</span>
            <span style="color: #00bcff;">1</span>
          <span style="color: #80d200;">}</span>
        <span style="color: #00bcff;">}</span>
        failures + failure
      <span style="color: #f0ce43;">}</span>
    <span style="color: #6ae4b9;">}</span>
  <span style="color: #b6a0ff;">}</span>
  
  println<span style="color: #b6a0ff;">(</span><span style="color: #79a8ff;">"+---------------------------------------------------"</span><span style="color: #b6a0ff;">)</span>
  println<span style="color: #b6a0ff;">(</span><span style="color: #79a8ff;">"| "</span> + failed + <span style="color: #79a8ff;">" tests failed"</span><span style="color: #b6a0ff;">)</span>
  println<span style="color: #b6a0ff;">(</span><span style="color: #79a8ff;">"+---------------------------------------------------"</span><span style="color: #b6a0ff;">)</span>
<span style="color: #00cd68;">}</span>

runTests<span style="color: #00cd68;">(</span>providedTests<span style="color: #00cd68;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-Ruby" class="outline-4">
<h4 id="Ruby">Ruby</h4>
<div class="outline-text-4" id="text-Ruby">
<p>
<a href="./testing/a2_test.rb">a2_test.rb</a>
</p>
<div class="org-src-container">
<pre class="src src-ruby"><span style="color: #f78fe7;">require_relative</span> <span style="color: #79a8ff;">"a2"</span>
<span style="color: #f78fe7;">require_relative</span> <span style="color: #79a8ff;">"a2_ulterm"</span>
<span style="color: #f78fe7;">require</span> <span style="color: #79a8ff;">"test/unit"</span>

<span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">ProvidedTests</span> &lt; <span style="color: #6ae4b9;">Test</span>::<span style="color: #6ae4b9;">Unit</span>::<span style="color: #6ae4b9;">TestCase</span>

  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Positive type checking tests</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">test_simple0</span>
    assert_equal<span style="color: #00cd68;">(</span><span style="color: #00bcff;">true</span>, <span style="color: #6ae4b9;">STZero</span>.new.typecheck, <span style="color: #79a8ff;">"Typecheck zero"</span><span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">test_simple1</span>
    assert_equal<span style="color: #00cd68;">(</span><span style="color: #00bcff;">true</span>, <span style="color: #6ae4b9;">STSuc</span>.new<span style="color: #b6a0ff;">(</span><span style="color: #6ae4b9;">STZero</span>.new<span style="color: #b6a0ff;">)</span>.typecheck, <span style="color: #79a8ff;">"Typecheck one"</span><span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">test_simple2</span>
    assert_equal<span style="color: #00cd68;">(</span><span style="color: #00bcff;">true</span>, <span style="color: #6ae4b9;">STIsZero</span>.new<span style="color: #b6a0ff;">(</span><span style="color: #6ae4b9;">STZero</span>.new<span style="color: #b6a0ff;">)</span>.typecheck, <span style="color: #79a8ff;">"Typecheck iszero zero"</span><span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">test_simple3</span>
    assert_equal<span style="color: #00cd68;">(</span><span style="color: #00bcff;">true</span>, <span style="color: #6ae4b9;">STTrue</span>.new.typecheck, <span style="color: #79a8ff;">"Typecheck true"</span><span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">test_simple4</span>
    assert_equal<span style="color: #00cd68;">(</span><span style="color: #00bcff;">true</span>, <span style="color: #6ae4b9;">STFalse</span>.new.typecheck, <span style="color: #79a8ff;">"Typecheck false"</span><span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">test_simple5</span>
    assert_equal<span style="color: #00cd68;">(</span><span style="color: #00bcff;">true</span>,
                 <span style="color: #6ae4b9;">STTest</span>.new<span style="color: #b6a0ff;">(</span><span style="color: #6ae4b9;">STTrue</span>.new,<span style="color: #6ae4b9;">STZero</span>.new,<span style="color: #6ae4b9;">STZero</span>.new<span style="color: #b6a0ff;">)</span>.typecheck,
                 <span style="color: #79a8ff;">"Typecheck test true zero zero"</span><span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">test_simple6</span>
    assert_equal<span style="color: #00cd68;">(</span><span style="color: #00bcff;">true</span>,
                 <span style="color: #6ae4b9;">STAbs</span>.new<span style="color: #b6a0ff;">(</span><span style="color: #6ae4b9;">STNat</span>.new,<span style="color: #6ae4b9;">STVar</span>.new<span style="color: #6ae4b9;">(</span>0<span style="color: #6ae4b9;">)</span><span style="color: #b6a0ff;">)</span>.typecheck,
                 <span style="color: #79a8ff;">"Typecheck lambda x : nat . x"</span><span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">test_simple7</span>
    assert_equal<span style="color: #00cd68;">(</span><span style="color: #00bcff;">true</span>,
                 <span style="color: #6ae4b9;">STApp</span>.new<span style="color: #b6a0ff;">(</span><span style="color: #6ae4b9;">STAbs</span>.new<span style="color: #6ae4b9;">(</span><span style="color: #6ae4b9;">STNat</span>.new,<span style="color: #6ae4b9;">STVar</span>.new<span style="color: #f0ce43;">(</span>0<span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>,<span style="color: #6ae4b9;">STZero</span>.new<span style="color: #b6a0ff;">)</span>.typecheck,
                 <span style="color: #79a8ff;">"Typecheck (lambda x : nat . x) (zero)"</span><span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>

  <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Negative typechecking tests  </span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">test_simple8</span>
    assert_equal<span style="color: #00cd68;">(</span><span style="color: #00bcff;">false</span>,
                 <span style="color: #6ae4b9;">STSuc</span>.new<span style="color: #b6a0ff;">(</span><span style="color: #6ae4b9;">STFalse</span>.new<span style="color: #b6a0ff;">)</span>.typecheck,
                 <span style="color: #79a8ff;">"Successor of false should not typecheck."</span><span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">test_simple9</span>
    assert_equal<span style="color: #00cd68;">(</span><span style="color: #00bcff;">false</span>,
                 <span style="color: #6ae4b9;">STVar</span>.new<span style="color: #b6a0ff;">(</span>0<span style="color: #b6a0ff;">)</span>.typecheck,
                 <span style="color: #79a8ff;">"Free variables should not typecheck"</span><span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">test_simple10</span>
    assert_equal<span style="color: #00cd68;">(</span><span style="color: #00bcff;">false</span>,
                 <span style="color: #6ae4b9;">STApp</span>.new<span style="color: #b6a0ff;">(</span><span style="color: #6ae4b9;">STAbs</span>.new<span style="color: #6ae4b9;">(</span><span style="color: #6ae4b9;">STNat</span>.new,<span style="color: #6ae4b9;">STVar</span>.new<span style="color: #f0ce43;">(</span>0<span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>,<span style="color: #6ae4b9;">STFalse</span>.new<span style="color: #b6a0ff;">)</span>.typecheck,
                 <span style="color: #79a8ff;">"Applying a boolean to a natural function should not typecheck"</span><span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>

  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">test_simple11</span>
    assert_equal<span style="color: #00cd68;">(</span><span style="color: #6ae4b9;">ULAbs</span>.new<span style="color: #b6a0ff;">(</span><span style="color: #6ae4b9;">ULAbs</span>.new<span style="color: #6ae4b9;">(</span><span style="color: #6ae4b9;">ULVar</span>.new<span style="color: #f0ce43;">(</span>1<span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span><span style="color: #b6a0ff;">)</span>, <span style="color: #6ae4b9;">STTrue</span>.new.eraseTypes, <span style="color: #79a8ff;">"Erase types of true"</span><span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">test_simple12</span>
    assert_equal<span style="color: #00cd68;">(</span><span style="color: #6ae4b9;">ULApp</span>.new<span style="color: #b6a0ff;">(</span>
                   <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Encoding of suc</span>
                   <span style="color: #6ae4b9;">ULAbs</span>.new<span style="color: #6ae4b9;">(</span> <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">lambda n .</span>
                     <span style="color: #6ae4b9;">ULAbs</span>.new<span style="color: #f0ce43;">(</span> <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">lambda s.</span>
                       <span style="color: #6ae4b9;">ULAbs</span>.new<span style="color: #00bcff;">(</span> <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">lambda z.</span>
                         <span style="color: #6ae4b9;">ULApp</span>.new<span style="color: #80d200;">(</span><span style="color: #6ae4b9;">ULVar</span>.new<span style="color: #f78fe7;">(</span>1<span style="color: #f78fe7;">)</span>,<span style="color: #6ae4b9;">ULApp</span>.new<span style="color: #f78fe7;">(</span><span style="color: #6ae4b9;">ULApp</span>.new<span style="color: #4ae8fc;">(</span><span style="color: #6ae4b9;">ULVar</span>.new<span style="color: #cfdf30;">(</span>2<span style="color: #cfdf30;">)</span>,<span style="color: #6ae4b9;">ULVar</span>.new<span style="color: #cfdf30;">(</span>1<span style="color: #cfdf30;">)</span><span style="color: #4ae8fc;">)</span>,<span style="color: #6ae4b9;">ULVar</span>.new<span style="color: #4ae8fc;">(</span>0<span style="color: #4ae8fc;">)</span><span style="color: #f78fe7;">)</span><span style="color: #80d200;">)</span><span style="color: #00bcff;">)</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>, <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">s (n s z)</span>
                   <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Encoding of zero</span>
                   <span style="color: #6ae4b9;">ULAbs</span>.new<span style="color: #6ae4b9;">(</span> <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">lambda s .</span>
                     <span style="color: #6ae4b9;">ULAbs</span>.new<span style="color: #f0ce43;">(</span> <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">lambda z .</span>
                       <span style="color: #6ae4b9;">ULVar</span>.new<span style="color: #00bcff;">(</span>0<span style="color: #00bcff;">)</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span><span style="color: #b6a0ff;">)</span>, <span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">z</span>
                 <span style="color: #6ae4b9;">STSuc</span>.new<span style="color: #b6a0ff;">(</span><span style="color: #6ae4b9;">STZero</span>.new<span style="color: #b6a0ff;">)</span>.eraseTypes,
                 <span style="color: #79a8ff;">"Erase types of one"</span><span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">test_simple13</span>
    assert_equal<span style="color: #00cd68;">(</span><span style="color: #6ae4b9;">ULApp</span>.new<span style="color: #b6a0ff;">(</span><span style="color: #6ae4b9;">ULAbs</span>.new<span style="color: #6ae4b9;">(</span>          <span style="color: #6ae4b9;">ULVar</span>.new<span style="color: #f0ce43;">(</span>0<span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>,<span style="color: #6ae4b9;">ULAbs</span>.new<span style="color: #6ae4b9;">(</span><span style="color: #6ae4b9;">ULAbs</span>.new<span style="color: #f0ce43;">(</span><span style="color: #6ae4b9;">ULVar</span>.new<span style="color: #00bcff;">(</span>0<span style="color: #00bcff;">)</span><span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span><span style="color: #b6a0ff;">)</span>,
                 <span style="color: #6ae4b9;">STApp</span>.new<span style="color: #b6a0ff;">(</span><span style="color: #6ae4b9;">STAbs</span>.new<span style="color: #6ae4b9;">(</span><span style="color: #6ae4b9;">STNat</span>.new,<span style="color: #6ae4b9;">STVar</span>.new<span style="color: #f0ce43;">(</span>0<span style="color: #f0ce43;">)</span><span style="color: #6ae4b9;">)</span>,<span style="color: #6ae4b9;">STZero</span>.new<span style="color: #b6a0ff;">)</span>.eraseTypes,
                 <span style="color: #79a8ff;">"Erase types of (lambda x : nat . x) (zero)"</span><span style="color: #00cd68;">)</span>
  <span style="color: #b6a0ff;">end</span>
<span style="color: #b6a0ff;">end</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-The-Docker-setup" class="outline-3">
<h3 id="The-Docker-setup">The Docker setup</h3>
<div class="outline-text-3" id="text-The-Docker-setup">
<p>
<a href="./testing/a2/Dockerfile">Dockerfile</a>
</p>
<div class="org-src-container">
<pre class="src src-docker"># Define the argument for openjdk version
ARG OPENJDK_TAG=8u232

FROM ruby:2.7.2-buster

# Setup to install Scala
RUN apt-get update &amp;&amp; \
    apt-get install scala -y &amp;&amp; \
    apt-get install -y curl &amp;&amp; \
    sh -c '(echo "#!/usr/bin/env sh" &amp;&amp; \
    curl -L https://github.com/lihaoyi/Ammonite/releases/download/2.1.1/2.12-2.1.1) &gt; /usr/local/bin/amm &amp;&amp; \
    chmod +x /usr/local/bin/amm'
RUN (rm -rf /root/.cache)
     
# Set the name of the maintainers
MAINTAINER Habib Ghaffari Hadigheh, Mark Armstrong &lt;ghaffh1@mcmaster.ca, armstmp@mcmaster.ca&gt;

# Set the working directory
WORKDIR /opt/a2
</pre>
</div>

<p>
<a href="./testing/a2/docker-compose.yml">docker-compose.yml</a>
</p>
<div class="org-src-container">
<pre class="src src-yaml">version: '2'
services:
  service:
    build: .
    image: 3mi3_a2_docker_image
    volumes:
      - .:/opt/a2
    container_name: 3mi3_a2_container
    command: bash -c
      "echo 'Scala testing' &amp;&amp;
       echo '----------------------------------------------------------------------' &amp;&amp;
       amm a2_test.sc &amp;&amp;
       printf '\\n\\n\\n' &amp;&amp;
       echo 'Ruby testing' &amp;&amp;
       echo '----------------------------------------------------------------------' &amp;&amp;
       ruby a2_test.rb &amp;&amp;
       echo '----------------------------------------------------------------------'"
</pre>
</div>

<p>
<a href="./testing/a2/setup.sh">setup.sh</a>
</p>
<div class="org-src-container">
<pre class="src src-shell">docker-compose build --force-rm
</pre>
</div>

<p>
<a href="./testing/a2/run.sh">run.sh</a>
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Run the container</span>
docker-compose up --force-recreate
<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">Stop the container after finishing the test run</span>
docker-compose stop -t 1
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Mark Armstrong</p>
     <p class="author">Contact: <a href="mailto:markparmstrong@gmail.com">markparmstrong@gmail.com</a></p>
     <p class="date">Original date: October 30th, 2020</p>
     <p class="date">Last updated: 2020-11-10 Tue 15:53</p>
     <p class="creator">Created using <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.0.91 (<a href="https://orgmode.org">Org</a> mode 9.4)</p>
     <p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
