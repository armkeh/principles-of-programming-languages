<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Formal languages</title>
<meta name="author" content="(Mark Armstrong)"/>
<meta name="description" content="Definition and tools for building formal languages.
Introduction to semantics."/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/dist/theme/black.css" id="theme"/>

<link rel="stylesheet" href="local.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h2 class="title">Formal languages</h2>
   <h3>Principles of Programming Languages</h3>
   <h4>Mark Armstrong</h4>
   <h5>Fall 2020</h5>
</section>

<section>
<section id="slide-orga209851">
<h2 id="orga209851"><span class="section-number-2">1</span> Preamble</h2>
<p>
This section introduces the mathematical tools
we will use in the discussion of programming languages
as a <i>formal</i> language.
</p>

<p>
Several small formal languages (not full programming languages)
are used as examples of the use of these tools.
</p>

</section>
<section id="slide-orgfaec909">
<h3 id="orgfaec909"><span class="section-number-3">1.1</span> <span class="todo TODO">TODO</span> Table of contents</h3>
<font size="-1">
<div class="scriptsize" id="orgd3ebdd9">
<p>

</p>

</div>
</font>

</section>
<section id="slide-orgbc8d0c7">
<h3 id="orgbc8d0c7"><span class="section-number-3">1.2</span> <span class="todo TODO">TODO</span> Notable references</h3>
<p>
:TODO:
</p>

</section>
</section>
<section>
<section id="slide-org1a07f9d">
<h2 id="org1a07f9d"><span class="section-number-2">2</span> Formal languages</h2>
<p>
Recall, from formal language theory:
</p>

<p>
A language over an <i>alphabet</i> (set of symbols) \(Œ£\)
is a subset of \(Œ£^{*}\).
The elements of a language are called <i>sentences</i>
(or <i>strings</i> or sometimes <i>words</i>).
</p>

<p>
A <i>formal</i> language is one for which we have a mathematical tool
for either
</p>
<ul>
<li><i>generating</i> (or <i>deriving</i>) all sentences of the language,
or equivalently,</li>
<li><i>recognising</i> (or <i>accepting</i>) only sentences of the language.</li>

</ul>

<p>
Examples of such mathematical tools include
</p>
<ul>
<li>regular expressions,</li>
<li>automata, and</li>
<li>grammars.</li>

</ul>

</section>
<section id="slide-orgfd12c15">
<h3 id="orgfd12c15"><span class="section-number-3">2.1</span> The usefulness of formal languages</h3>
<p>
Formal languages, unlike <i>natural</i> languages, are well-suited
for comprehension by computers.
</p>
<ul>
<li>Machines require unambiguous steps to follow.</li>
<li>Hence, all programming languages are formal languages.</li>

</ul>

<p>
In particular, in most cases:
</p>
<ul>
<li>The sets of keywords, names, etc., form several <i>regular languages</i>,
and so can be recognised by regular expressions.</li>
<li>The set of valid (in terms of form) programs forms
a <i>context-free</i> language, and so can be recognised by
a (context-free) grammar.</li>

</ul>

</section>
<section id="slide-orgb5040f3">
<h3 id="orgb5040f3"><span class="section-number-3">2.2</span> Strings</h3>
<p>
Recall that given a set \(Œ£\), the set of strings over \(Œ£\),
written \(Œ£^{*}\), is the set of all finite sequences
of elements of \(Œ£\).
</p>

<p>
In particular, the sequence of length zero we denote by \(Œµ\).
Note that some other sources use \(Œª\) for this purpose.
</p>

<p>
For example, for \(Œ£ = \{a, b, c\}\),
</p>
<div class="org-center">
<p>
\(Œ£^{*} = \{Œµ, a, b, c, aa, ab, ac, ba, bb, bc, ca, cb, cc, aaa, ‚Ä¶\}\).
</p>
</div>

<p>
Given an element \(e ‚àà Œ£\), we write
</p>
<ul>
<li>\(e^{n}\) for the string consisting of \(n\) occurrences of \(e\), and</li>
<li>\(e^{*}\) for the set \(\{ n ‚àà ‚Ñï ‚à£ e^{n} \}\).</li>

</ul>

</section>
</section>
<section>
<section id="slide-org486c98a">
<h2 id="org486c98a"><span class="section-number-2">3</span> Describing the <i>syntax</i> of formal languages</h2>
<p>
In this section, we will
</p>
<ul>
<li>briefly review regular expressions and grammars as
they are presented in formal language theory, and then</li>
<li>introduce more practical syntax for each
which is used in practice.</li>

</ul>

<p>
In both cases, the additional syntax only adds to
the <i>practical expressiveness</i> of the tool.
</p>
<ul>
<li>It does not change the tool's <i>theoretical expressiveness</i>.
<ul>
<li>The same set of languages can be described,
but many languages can be described ‚Äúmore easily‚Äù.</li>

</ul></li>
<li>We will present brief arguments to this effect
by showing how to translate from the new syntax
to the restricted syntax.</li>

</ul>

</section>
<section id="slide-org8958f4d">
<h3 id="org8958f4d"><span class="section-number-3">3.1</span> Regular expressions as in formal language theory</h3>
<p>
Given a finite alphabet \(Œ£\),
the set of regular expressions (over \(Œ£\)),
denoted \(RE(Œ£)\), is given
by the following rules.
</p>
<ol>
<li>\(‚àÖ\), \(Œµ\) and \(a\) (for each \(a ‚àà Œ£\)) are regular expressions.</li>
<li>\((Œ± | Œ≤)\), \((Œ±Œ≤)\) and \((Œ±*)\) are regular expressions
<ul>
<li>for any regular expressions Œ± and Œ≤.</li>

</ul></li>

</ol>

<p>
Respectively, the three operations in (2) are called
</p>
<ul>
<li>‚Äúor‚Äù,</li>
<li>‚Äúappend‚Äù, and</li>
<li>‚Äústar‚Äù or ‚Äúrepeat‚Äù.</li>

</ul>

</section>
<section id="slide-org45dadf4">
<h3 id="org45dadf4"><span class="section-number-3">3.2</span> The language for a regular expression</h3>
<p>
The language generated/recognised by a regular expression
is defined via a (semantic) function \(L : RE(Œ£) ‚Üí Œ£^{*}\),
defined as follows.
</p>
<ul>
<li>\(L(‚àÖ) = ‚àÖ\)</li>
<li>\(L(Œµ) = \{ Œµ \}\)</li>
<li>\(L(a) = \{ a \}\)</li>
<li>\(L(Œ± | Œ≤) = L(Œ±) ‚à™ L(Œ≤)\)</li>
<li>\(L(Œ±Œ≤) = \{ uv | u ‚àà L(Œ±) ‚àß v ‚àà L(b) \}\)</li>
<li>\(L(Œ±*) = (L(Œ±))^{*}\)</li>

</ul>

</section>
<section id="slide-orge3e6272">
<h3 id="orge3e6272"><span class="section-number-3">3.3</span> Additional operators for more expressive regular expressions</h3>
<p>
Regular expressions come up frequently in programming,
and there is a rich set of extensions
to make them easier to construct.
</p>

<p>
We will not try to extensively list them, but some are listed below,
along with their equivalent ‚Äúbasic‚Äù form or,
where that is infeasible to write,
its language.
</p>
<ol>
<li>\(Œ±^{+} \ \ \ ‚âà \ \ \ Œ±Œ±^{*}\)</li>
<li>\(Œ±? \ \ \ ‚âà \ \ \ Œ± | Œµ\)</li>
<li>\(\text{.} \ \ \ ‚âà \ \ \ a | b | c | ‚Ä¶\) where \(Œ£ = {a, b, c, ‚Ä¶}\); i.e., \(L(.) = Œ£\)</li>
<li>\([c_{1}‚Ä¶c_{n}] \ \ \ ‚âà \ \ \ c_{1} | ‚Ä¶ | c_{n}\), where each \(c_{i}\) is a character.</li>
<li>\([\text{\^{}}c_{1}‚Ä¶c_{n}]\), where \(L([\text{\^{}}c_{1}‚Ä¶c_{n}]) = Œ£ - [c_{1}‚Ä¶c_{n}]\).</li>
<li>\(Œ±\{m,n\}\), where \(L(Œ±\{m,n\}) = ‚ãÉ_{i=m}^{n} L(Œ±)^{i}\)</li>

</ol>

</section>
<section id="slide-org72a141c">
<h3 id="org72a141c"><span class="section-number-3">3.4</span> Regular expression examples</h3>
<p>
:TODO:
</p>

</section>
<section id="slide-org2dff269">
<h3 id="org2dff269"><span class="section-number-3">3.5</span> Grammars as in formal language theory</h3>
<p>
Formally, a context-free grammar is a 4-tuple
</p>
<div class="org-center">
<p>
\(‚ü®N, Œ£, P, S‚ü©\)
</p>
</div>
<p>
where
</p>
<ul>
<li>\(N\) is a finite set of <i>non-terminal</i> symbols
(sometimes called variables),</li>
<li>\(Œ£\) is the underlying alphabet,
also called the <i>terminals</i> of the grammar,</li>
<li>\(N\) and \(Œ£\) must be distinct,</li>
<li>\(P\) is a set of <i>productions</i> i.e.,
a binary relation between \(N\) and \((N ‚à™ Œ£)^{*}\),
<ul>
<li>In other words, a multi-valued function from
nonterminals to strings of non-terminals and terminals,</li>

</ul></li>
<li>\(S\) is a distinguished element of \(N\), called the <i>starting nonterminal</i>.</li>

</ul>

</section>
<section id="slide-org2c228bc">
<h3 id="org2c228bc"><span class="section-number-3">3.6</span> Notations for grammar productions in formal language theory</h3>
<p>
Given
</p>
<div class="org-center">
<p>
\((A, Œ±) ‚àà P\),
</p>
</div>
<p>
we write
</p>
<div class="org-center">
<p>
\(A ‚ü∂ Œ±\)
</p>
</div>
<p>
and read it as
</p>
<div class="org-center">
<p>
‚Äú\(A\) produces \(Œ±\)‚Äù or ‚Äú\(A\) expands to \(Œ±\)‚Äù.
</p>
</div>

<p>
Given a number of
productions
</p>
<div class="org-center">
<p>
\((A, Œ±‚ÇÅ) ‚àà P\), \((A, Œ±‚ÇÇ) ‚àà P\), ‚Ä¶, \((A, Œ±‚Çò) ‚àà P\),
</p>
</div>
<p>
we write
</p>
<div class="org-center">
<p>
\(A ‚ü∂ Œ±‚ÇÅ | Œ±‚ÇÇ | ‚Ä¶ | Œ±‚Çò\)
</p>
</div>
<p>
as a shorthand.
</p>

</section>
<section id="slide-org72bda6d">
<h3 id="org72bda6d"><span class="section-number-3">3.7</span> Conventions for grammars</h3>
<p>
Writing the 4-tuple each time we produce a grammar is tedious.
</p>

<p>
For this reason, we adopt the following conventions
in order to allow us to omit the 4-tuple.
</p>
<ol>
<li>We write <i>only</i> the list of productions.</li>
<li>The set \(N\) is taken to be the set of all symbols
appearing to the left of a list of productions.
<ul>
<li>Note that this requires each nonterminal have
at least one production.</li>

</ul></li>
<li>The set \(Œ£\) is usually understood by the context
in which we are defining the grammer.
<ul>
<li>For our purposes, it will usually be the set of
all ASCII symbols.</li>

</ul></li>
<li>The starting nonterminal \(S\) is understood to be either
<ol>
<li>the nonterminal whose name matches that of the grammar
we are defining (it may be uncapitalised or abbreviated),</li>
<li>otherwise, the non-terminal named \(S\), or</li>
<li>otherwise, the nonterminal to the left of
the first production in the list.
<ul>
<li>(We usually attempt to write grammars ‚Äútop down‚Äù.)</li>

</ul></li>

</ol></li>

</ol>

</section>
<section id="slide-orgdf0a48a">
<h3 id="orgdf0a48a"><span class="section-number-3">3.8</span> A simple example grammar</h3>
<div class="org-src-container">

<pre  class="src src-text"><code trim>A &#10230; aAa | B
B &#10230; bBb | C
C &#10230; cCc | &#949;
</code></pre>
</div>

<p>
This produces the language of strings of
the form
</p>
<div class="org-center">
<p>
\(a^{i}b^{j}c^{k}c^{k}b^{j}a^{i}\)
</p>
</div>

</section>
<section id="slide-orgf74f2ba">
<h3 id="orgf74f2ba"><span class="section-number-3">3.9</span> Exercise ‚Äì reading grammars</h3>
<p>
What languages do the following grammars produce?
</p>

<div class="org-src-container">

<pre  class="src src-text"><code trim>A &#10230; B | C
B &#10230; aaB | &#949;
C &#10230; aaaC | &#949;
</code></pre>
</div>

<div class="org-src-container">

<pre  class="src src-text"><code trim>A &#10230; aB | B | &#949;
B &#10230; bC | C
C &#10230; cA | A
</code></pre>
</div>

<div class="org-src-container">

<pre  class="src src-text"><code trim>A &#10230; aA | B
B &#10230; bB
</code></pre>
</div>

<p>
<b>What's the tricky part with the last one?</b>
</p>

<p>
Extra exercise: can you simplify any of them?
For instance, by having less non-terminals or less productions?
If you believe so, just be careful that
your simplification accepts the same string!
</p>

</section>
<section id="slide-org844239a">
<h3 id="org844239a"><span class="section-number-3">3.10</span> Grammars generate or recognise strings</h3>
<p>
We have discussed the facts that a grammar can
</p>
<ul>
<li>generate strings or</li>
<li>recognise/accept strings.</li>

</ul>

<p>
Then for a grammar \(G\) we might think of functions
</p>
<ul>
<li>\(generate·¥≥ : ‚Ñï ‚Üí Œ£^{*}\)
<ul>
<li>with the intention that \(generate·¥≥ n\) generates the \(n^{th}\)
string in the grammar's language is lexicographic order</li>

</ul></li>
<li>\(recognise·¥≥ : Œ£^{*} ‚Üí Bool\)</li>

</ul>
<p>
That is, we have two functions, which output a <code>String</code> or
a <code>Bool</code> respectively.
</p>

<p>
But there is a useful byproduct which may be obtained during
during either process: a <i>parse tree</i>.
</p>

</section>
<section id="slide-org617ab58">
<h3 id="org617ab58"><span class="section-number-3">3.11</span> Parse trees</h3>
<p>
A parse tree's
</p>
<ul>
<li>nodes (which have children) are
labelled by a nonterminal of the grammar,</li>
<li>leaves (which do not have children) are
labelled by a terminal of the grammar
(or a nonterminal which may produce \(Œµ\)), and</li>
<li>if a node is labelled by a nonterminal <code>A</code>,
the children of that node must correspond
(in order from left to right)
the nonterminals appearing in a production of <code>A</code>.</li>

</ul>

</section>
<section id="slide-org2c01c39">
<h3 id="org2c01c39"><span class="section-number-3">3.12</span> Example parse tree</h3>
<p>
For example, if we consider the grammar
</p>
<div class="org-src-container">

<pre  class="src src-text"><code trim>S &#10230; AB
A &#10230; aA | &#949;
B &#10230; Bb | b
</code></pre>
</div>
<p>
the following are valid parse trees.
</p>

<p>
First, for the string <code>aab</code>.
</p>

<div id="org2de4612" class="figure">
<p><img src="media/parse-tree-example-aab.png" alt="parse-tree-example-aab.png" />
</p>
</div>

</section>
<section id="slide-orge97b0a3">
<h3 id="orge97b0a3"><span class="section-number-3">3.13</span> Another example parse tree</h3>
<p>
Similarly, working with the same grammar,
we have the following parse tree for <code>abb</code>.
</p>

<div id="orgd3cf72a" class="figure">
<p><img src="media/parse-tree-example-abb.png" alt="parse-tree-example-abb.png" />
</p>
</div>

</section>
<section id="slide-orgb37c5e3">
<h3 id="orgb37c5e3"><span class="section-number-3">3.14</span> Exercise: creating parse trees</h3>
<p>
Exercise: provide a parse tree for the string <code>aaa</code> using this grammar.
Is there a valid parse tree for the string <code>bbb</code>?
</p>

<p>
Exercise: if we add a production <code>A ‚ü∂ a</code> to our example grammar,
can you provide a different parse tree
(or multiple different parse trees) for <code>aaa</code>?
</p>

</section>
<section id="slide-orgb140e29">
<h3 id="orgb140e29"><span class="section-number-3">3.15</span> Backus-Naur form (BNF)</h3>
<p>
Up until now, we have used the form
</p>
<pre class="example" id="orgabd10b0">
N‚ÇÅ ‚ü∂ P‚ÇÅ | P‚ÇÇ | ‚Ä¶
   ‚ãÆ
</pre>
<p>
for our production lists.
</p>

<p>
Commonly in the study of programming languages,
an alternative syntax called <i>Backus-Naur</i> form (BNF)
is used.
</p>
<ul>
<li>Named for two members of the ALGOL design committee,
who created the first formal definition for a programming language,
namely ALGOL.</li>

</ul>

</section>
<section id="slide-orga7b4592">
<h3 id="orga7b4592"><span class="section-number-3">3.16</span> BNF details</h3>
<p>
In Backus-Naur form,
</p>
<ul>
<li>all nonterminals names are delimited by
angle brackets, <code>‚ü®‚ü©</code>,
<ul>
<li>(if using ASCII characters, <code>&lt;&gt;</code>)</li>

</ul></li>
<li>the <code>‚ü∂</code> is replaced by <code>‚à∑=</code>,</li>
<li>additional whitespace is permitted on the right side
of a production between terminals and nonterminals,
without changing the meaning of the production
<ul>
<li>So \(‚ü®A‚ü© ‚à∑= a a ‚ü®A‚ü©\) is treated the same as \(‚ü®A‚ü© ‚à∑= aa‚ü®A‚ü©\).</li>

</ul></li>

</ul>

</section>
<section id="slide-org3982f62">
<h3 id="org3982f62"><span class="section-number-3">3.17</span> Aside: ALGOL</h3>
<p>
ALGOL (for ‚ÄúALGOrithmic Language‚Äù)
was a contemporary of Fortran, Lisp, and Cobol.
</p>
<ul>
<li>Together, those three are the oldest languages
still in (fairly) common use today.
<ul>
<li>Granted, not the same versions.</li>

</ul></li>

</ul>

<p>
Specifically, there were several iterations of ALCOL,
the three major ones being ALGOL 58, ALGOL 60 and ALGOL 68.
</p>

<p>
ALGOL is not in common use, but it was
the most influential on modern programming language syntax,
introducing concepts such as the block.
</p>
<ul>
<li>The ‚ÄúC family‚Äù can trace its lineage directly to ALGOL.</li>

</ul>

</section>
<section id="slide-org9562c02">
<h3 id="org9562c02"><span class="section-number-3">3.18</span> Extended Backus-Naur form (EBNF)</h3>
<p>
We further extend our grammar notation to include several
several additional operators.
</p>
<ul>
<li>These extensions are part of the <i>extended</i> Backus-Naur form.</li>
<li>Once again, this is only an extension in the <i>practicality</i> sense.</li>

</ul>

<p>
There is an <a href="https://www.iso.org/standard/26153.html">ISO standard</a> for EBNF.
Our syntax and inclusion of features is
not chosen to match the standard;
it is what is convenient for our use.
</p>

</section>
<section id="slide-org5e344f1">
<h3 id="org5e344f1"><span class="section-number-3">3.19</span> EBNF details</h3>
<ul>
<li>(Square) brackets, <code>[]</code>, surrounding a string
indicate that string may or may not be included in a production.
<ul>
<li>I.e., they make part of a production optional.</li>
<li>\(‚ü®A‚ü© ‚à∑= Œ±‚ÇÅ [ Œ±‚ÇÇ ] Œ±‚ÇÉ \ \ \ ‚âà \ \ \ ‚ü®A‚ü© ‚à∑= Œ±‚ÇÅ Œ±‚ÇÇ Œ±‚ÇÉ | Œ±‚ÇÅ Œ±‚ÇÉ\).</li>

</ul></li>
<li>(Curly) braces, <code>{}</code>, surrounding a string
indicate that string may be repeated any number of times,
including zero.
<ul>
<li>\(‚ü®A‚ü© ‚à∑= Œ±‚ÇÅ { Œ±‚ÇÇ } Œ±‚ÇÉ \ \ \ ‚âà \ \ \ ‚ü®A‚ü© ‚à∑= Œ±‚ÇÅ ‚ü®A‚Ä≤‚ü© Œ±‚ÇÉ\) together
with \(‚ü®A‚Ä≤‚ü© ‚à∑= Œ±‚ÇÇ ‚ü®A‚Ä≤‚ü© | Œµ\).</li>

</ul></li>
<li>Parentheses, <code>()</code>, may group parts of a string.</li>
<li>The ‚Äúalternative‚Äù pipe, <code>|</code>, may be used <i>inside</i> of productions,
to indicate alternatives inside a set of brackets, braces
or parentheses.
<ul>
<li>\(‚ü®A‚ü© ‚à∑= Œ±‚ÇÅ (Œ±‚ÇÇ | Œ±‚ÇÉ) Œ±‚ÇÑ \ \ \ ‚âà \ \ \ ‚ü®A‚ü© ‚à∑= Œ±‚ÇÅ Œ±‚ÇÇ Œ±‚ÇÑ | Œ±‚ÇÅ Œ±‚ÇÉ Œ±‚ÇÑ\).</li>

</ul></li>
<li>Where necessary, terminals may be single or double quoted,
such as to indicate a whitespace character, pipe or quote.
<ul>
<li>\(‚ü®ebnfprods‚ü© ‚à∑= ‚ü®string‚ü© | ‚ü®string‚ü© ‚ü®optws‚ü© ‚Äú|‚Äù ‚ü®optws‚ü© ‚ü®ebnfprods‚ü©\)</li>

</ul></li>

</ul>

</section>
<section id="slide-org73045a5">
<h3 id="org73045a5"><span class="section-number-3">3.20</span> Exercise ‚Äì translating to EBNF</h3>
<p>
Translate this grammar from an earlier exercise to EBNF syntax.
</p>
<div class="org-src-container">

<pre  class="src src-text"><code trim>A &#10230; B | C
B &#10230; aaB | &#949;
C &#10230; aaaC | &#949;
</code></pre>
</div>
<p>
Then try to reduce the number of productions in the grammar,
while maintaining the language defined.
</p>

<p>
Can you use only one production when using EBNF?
</p>

</section>
<section id="slide-org84e207b">
<h3 id="org84e207b"><span class="section-number-3">3.21</span> EBNF's syntactic sugar</h3>
<p>
EBNF gives us our first example of <i>syntactic sugar</i>;
syntax that does not add new features to a language,
only more convenient notation.
</p>
<ul>
<li>As shown above, any grammar using the additional operators
can be translated into one not using them.
<ul>
<li>But this likely requires more productions.</li>
<li>And certainly more characters/space on the page.</li>

</ul></li>

</ul>

<p>
Syntactic sugar is a common feature of programming languages.
</p>
<ul>
<li>Example: (imperative) languages often include various kinds of loops,
where only one (or sometimes none!) is truly necessary.</li>

</ul>

<p>
When we discuss programming languages formally,
we will usually omit constructs which are syntactic sugar.
</p>
<ul>
<li>If anything, we may note how to represent them
in a ‚Äúcore‚Äù language which includes less constructs.</li>

</ul>

</section>
<section id="slide-orgf4b2bd9">
<h3 id="orgf4b2bd9"><span class="section-number-3">3.22</span> Exercise ‚Äì a small language C-like language</h3>
<p>
Consider the following context-free language.
</p>
<pre class="example" id="orgd77fe71">
‚ü®stmt‚ü©   ‚à∑= ‚ü®assign‚ü© | ‚ü®stmt‚ü© "; " ‚ü®stmt‚ü© | "while " ‚ü®expr‚ü© " do " ‚ü®stmt‚ü© | ‚ü®ws‚ü© ‚ü®stmt‚ü© ‚ü®ws‚ü©
‚ü®assign‚ü© ‚à∑= ‚ü®var‚ü© ‚ü®ws‚ü© " := " ‚ü®expr‚ü©
‚ü®expr‚ü©   ‚à∑= ‚ü®var‚ü© | ‚ü®const‚ü© | ‚ü®expr‚ü© ‚ü®op‚ü© ‚ü®expr‚ü© | ‚ü®ws‚ü© ‚ü®expr‚ü© ‚ü®ws‚ü©
‚ü®var‚ü©    ‚à∑= ('x' | 'y' | 'z') {‚ü®var‚ü©}
‚ü®const‚ü©  ‚à∑= (1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0) {‚ü®const‚ü©}
‚ü®op‚ü©     ‚à∑= '+' | '-' | '*' | '/' | '&lt;' | '&gt;' | '='
‚ü®ws‚ü©     ‚à∑= {' '} | {'\n'}
</pre>

<p>
Provide some example programs in this language.
</p>

<p>
Can you precisely describe the language in English?
</p>

</section>
<section id="slide-orga547636">
<h3 id="orga547636"><span class="section-number-3">3.23</span> Example ‚Äì EBNF for C++</h3>
<p>
A good example of the practicality EBNF for specifying
the syntax of languages is this
<a href="http://www.externsoft.ch/download/cpp-iso.html">EBNF grammar for C++</a>
(presented in tabular form, rather than lists of productions
as we use).
</p>

<p>
The grammar is much, much larger than anything we will write,
but it is still quite concise for describing
a real-world programming language.
</p>

</section>
</section>
<section>
<section id="slide-orgfccc70c">
<h2 id="orgfccc70c"><span class="section-number-2">4</span> Parsing and executable code</h2>
<p>
We will briefly summarise the parsing process,
beginning with some important terms.
</p>
<ul>
<li>In this course, we are primarily interested in
the beginning of this process, up to the
construction of parse trees.</li>

</ul>

</section>
<section id="slide-org8e102b5">
<h3 id="org8e102b5"><span class="section-number-3">4.1</span> Atomic syntactic units</h3>
<p>
We have mentioned that both regular expressions and
context-free grammars are used in the description of
the syntax of programming languages.
</p>

<p>
However, our example programming language earlier
was described exclusively by a context-free grammar.
</p>
<ul>
<li>Even the smallest syntactic units of the language,
the <i>atomic</i> syntactic units, have been described by the grammars.
<ul>
<li>For instance, we have used the production
\(‚ü®const‚ü©  ‚à∑= (1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0) \{‚ü®const‚ü©\}\)
which describes numerical constants.</li>

</ul></li>

</ul>

<p>
This is not done in practice.
</p>

</section>
<section id="slide-org3b74208">
<h3 id="org3b74208"><span class="section-number-3">4.2</span> Lexemes and tokens</h3>
<p>
In practice,
</p>
<ul>
<li>regular expressions are instead used to describe the
atomic syntactic units of languages.
<ul>
<li>For example,
<ul>
<li>keywords such as <code>if</code> and <code>while</code>, constant values such as <code>0</code> or <code>"abc"</code>,
or names such as <code>height</code> or <code>sqrt</code>.</li>

</ul></li>
<li>Lexemes cannot be broken down into meaningful pieces.</li>

</ul></li>
<li>Grammars are then used to describe the possible arrangements
of lexemes.
<ul>
<li>The terminals of the grammar are then names for sets of lexemes,
called <i>tokens</i>, rather than elements of \(Œ£\).</li>
<li>For instance,
<ul>
<li>the token <code>while</code> for the set containing only the
keyword <code>while</code>,</li>
<li>or the token <code>int_literal</code> for the set \(\{ 0, 1, -1, 2, ‚Ä¶ \}\),</li>
<li>or the token <code>var</code> for the set of valid variable names.</li>

</ul></li>

</ul></li>

</ul>

</section>
<section id="slide-org2e25330">
<h3 id="org2e25330"><span class="section-number-3">4.3</span> Parsing</h3>
<p>
Parsing is the process of translating a program
from plaintext
to executable instructions
</p>
<ul>
<li><p>
whether this is done
</p>
<ul>
<li>ahead of time (compiling) or</li>
<li>when the program is to be run (interpreting),</li>

</ul>
<p>
parsing is a necessary step before execution.
</p></li>
<li>A computer cannot run unparsed higher level language code.</li>

</ul>

</section>
<section id="slide-orgb25525e">
<h3 id="orgb25525e"><span class="section-number-3">4.4</span> The zeroth step ‚Äì preprocessing</h3>
<p>
Many programming languages support some form
of <i>preprocessing directives</i> which are
to be carried out before the parsing process
properly begins.
</p>
<ul>
<li>Commonly, ‚Äúmacros‚Äù, which often are simply
textual substitutions to be carried out.
<ul>
<li>But they can be used for significantly more;
in some instances, macros form a whole language themselves.</li>

</ul></li>

</ul>

</section>
<section id="slide-orgd4cfde4">
<h3 id="orgd4cfde4"><span class="section-number-3">4.5</span> The first step ‚Äì lexical analysis</h3>
<p>
:TODO: There's a break in the narrative here.
</p>

<p>
We now know the first step in parsing.
</p>
<ul>
<li>Convert the plaintext source code into a sequence of tokens.
<ul>
<li>This process may be
called <i>lexical analysis</i>, <i>lexing</i> or <i>tokenising</i>.</li>
<li>The program to carry this process out may be
called a <i>lexer</i> or <i>tokeniser</i>.</li>
<li>Lexical analysis discards whitespace, comments, and any other
irrelevant text.</li>

</ul></li>

</ul>

</section>
<section id="slide-orgcfb68d8">
<h3 id="orgcfb68d8"><span class="section-number-3">4.6</span> The second step ‚Äì parsing (syntactic analysis)</h3>
<p>
After converting from plaintext to a string of tokens, the next
step of parsing is to construct the parse tree.
</p>

<p>
This step is part of the parsing process,
but it is also usually called parsing.
</p>
<ul>
<li>It may also be called <i>syntactic analysis</i>.</li>

</ul>

</section>
<section id="slide-orgddc7b37">
<h3 id="orgddc7b37"><span class="section-number-3">4.7</span> The third step ‚Äì (static) semantic analysis</h3>
<p>
:TODO:
</p>

</section>
<section id="slide-org166b6d2">
<h3 id="org166b6d2"><span class="section-number-3">4.8</span> The fourth step ‚Äì intermediate code generation</h3>
<p>
:TODO:
</p>

</section>
<section id="slide-orgaab16c8">
<h3 id="orgaab16c8"><span class="section-number-3">4.9</span> Visualising the entire parsing process</h3>

<div id="orgafa43be" class="figure">
<p><img src="media/parsing-whole.png" alt="parsing-whole.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-org541368a">
<h2 id="org541368a"><span class="section-number-2">5</span> Ambiguity</h2>
<div class="outline-text-2" id="text-5">
</div>
</section>
<section id="slide-org435e12f">
<h3 id="org435e12f"><span class="section-number-3">5.1</span> Ambiguity</h3>
<p>
Recall that parsing a string (or deriving a string)
using a grammar gives rise to a <i>parse tree</i> or <i>derivation tree</i>.
</p>

<p>
In many cases, there is more than one parse tree
for a given string in the language produced by a grammar.
</p>

<p>
For instance, the string <code>aa</code> has four valid parse trees
under the grammar
</p>
<div class="org-src-container">

<pre  class="src src-text"><code trim><span style="color: #00cd68;">&#10216;</span>A<span style="color: #00cd68;">&#10217;</span> &#8759;= a <span style="color: #00cd68;">&#10216;</span>A<span style="color: #00cd68;">&#10217;</span> | <span style="color: #00cd68;">&#10216;</span>A<span style="color: #00cd68;">&#10217;</span> a | &#949; 
</code></pre>
</div>

<p>
Exercise: find all four valid parse trees for <code>aa</code> with the above
grammar.
</p>

</section>
<section id="slide-org7b921c1">
<h3 id="org7b921c1"><span class="section-number-3">5.2</span> Removing ambiguity</h3>
<p>
It is desirable to have a single parse tree for every program.
</p>
<ul>
<li>We should not admit two syntactic interpretations for a program!</li>

</ul>

<p>
Three tools for removing ambiguity are
</p>
<ul>
<li>requiring parentheses,</li>
<li>introducing precedence rules, and</li>
<li>introducing associativity rules.</li>

</ul>

</section>
<section id="slide-org77dd4c8">
<h3 id="org77dd4c8"><span class="section-number-3">5.3</span> Enforcing precedence and associativity with grammars</h3>
<p>
To enforce precedence using a grammar:
</p>
<ul>
<li>Create a hierarchy of non-terminals.</li>
<li>Higher-precedence operators are produced lower in the hierarchy.</li>
<li>For instance,
<ul>
<li>An additive term can be a addition of multiplicative terms,
which is an addition of literals, which can be the negation
of a constant, variable or term.</li>

</ul></li>

</ul>

<p>
To enforce associativity using a grammar:
</p>
<ul>
<li>Left associative operators should be produced by left recursive
non-terminals.</li>
<li>And right associative operators by right recursive non-terminals.</li>
<li>Operators of the same precedence must associate the same way!</li>

</ul>

</section>
<section id="slide-orgfdbc986">
<h3 id="orgfdbc986"><span class="section-number-3">5.4</span> Is addition associative?</h3>
<p>
Recall that addition is an associative operator.
</p>
<ul>
<li>Meaning it is both left and right associative.</li>

</ul>

<p>
So the choice of whether addition in a language associates to
the right or to the left may seem arbitrary.
</p>
<ul>
<li>But numerical types in programming are not necessarily
the same as numerical types in math!</li>
<li>Addition of floating point numbers <i>is not associative</i>.
<ul>
<li>Consider a binary representation with two-digit coefficients.</li>
<li>1.0‚ÇÇ √ó 2‚Å∞ + 1.0‚ÇÇ √ó 2‚Å∞ + 1.0‚ÇÇ √ó 2¬≤ has a different value depending
upon parenthesisation.</li>

</ul></li>

</ul>

</section>
<section id="slide-org7374732">
<h3 id="org7374732"><span class="section-number-3">5.5</span> Abstract syntax</h3>
<p>
‚ÄúSimple‚Äù, ambiguous grammars do have a place in describing
programming language syntax.
</p>
<ul>
<li>Such grammars describe the <i>abstract syntax</i> of the language.
<ul>
<li>As opposed to <i>concrete syntax</i>.</li>

</ul></li>
<li>Consider programs as <i>trees</i> generated by the grammar
for the abstract syntax of the language.
<ul>
<li>Trees do not admit ambiguity!</li>
<li>Such trees more efficiently represent programs.
<ul>
<li>The shape of the tree expresses structure.</li>
<li>Other unnecessary details may be left out.</li>

</ul></li>

</ul></li>

</ul>

</section>
<section id="slide-orgc8776e6">
<h3 id="orgc8776e6"><span class="section-number-3">5.6</span> Beyond context-free grammars: ‚Äústatic semantics‚Äù</h3>
<p>
For most interesting languages,
context-free grammars are not quite sufficient
to describe well-formed programs.
</p>
<ul>
<li>They cannot express conditions such as
‚Äúvariables must be declared before use‚Äù, and
typing rules.</li>
<li>It has been <i>proven</i> that CFGs are not sufficient.
<ul>
<li>At least some typing rules are possible to express,
but prohibitively difficult.</li>

</ul></li>

</ul>

<p>
Recall the Chomsky hierarchy of languages.
</p>
<div class="org-src-container">

<pre  class="src src-text"><code trim>Regular &#8834; Context-free &#8834; Context-sensitive &#8834; Recursive &#8834; Recursively enumberable
</code></pre>
</div>
<ul>
<li>The properties we need could be described by <i>context-sensitive</i> grammars.
<ul>
<li>But they are unwieldy!</li>

</ul></li>
<li>Instead, use <i>attribute grammars</i>;
a relatively small augmentation to CFGs.
<ul>
<li>Each non-terminal and terminal may have a collection
of <i>attributes</i> (named values).</li>
<li>Each production may have a collection of
rules defining the values of the attributes
and a collection of predicates
reasoning about those attributes.</li>

</ul></li>

</ul>

</section>
<section id="slide-org82376d1">
<h3 id="org82376d1"><span class="section-number-3">5.7</span> An example attribute grammar</h3>
<p>
Consider this simple grammar.
</p>
<div class="org-src-container">

<pre  class="src src-text"><code trim><span style="color: #00cd68;">&#10216;</span>S<span style="color: #00cd68;">&#10217;</span> &#8759;= <span style="color: #00cd68;">&#10216;</span>A<span style="color: #00cd68;">&#10217;</span> <span style="color: #00cd68;">&#10216;</span>B<span style="color: #00cd68;">&#10217;</span> <span style="color: #00cd68;">&#10216;</span>C<span style="color: #00cd68;">&#10217;</span>
<span style="color: #00cd68;">&#10216;</span>A<span style="color: #00cd68;">&#10217;</span> &#8759;= &#949; &#8739; a <span style="color: #00cd68;">&#10216;</span>A<span style="color: #00cd68;">&#10217;</span>
<span style="color: #00cd68;">&#10216;</span>B<span style="color: #00cd68;">&#10217;</span> &#8759;= &#949; &#8739; b <span style="color: #00cd68;">&#10216;</span>B<span style="color: #00cd68;">&#10217;</span>
<span style="color: #00cd68;">&#10216;</span>C<span style="color: #00cd68;">&#10217;</span> &#8759;= &#949; &#8739; c <span style="color: #00cd68;">&#10216;</span>C<span style="color: #00cd68;">&#10217;</span>
</code></pre>
</div>

<p>
Suppose we want to allow only strings of the form <code>a‚Åøb‚Åøc‚Åø</code>.
There is no CFG that can produce exactly such strings.
But we can enforce this condition using the above grammar
augmented with attributes.
</p>
<ul>
<li>Each of the non-terminals <code>‚ü®A‚ü©</code>, <code>‚ü®B‚ü©</code> and <code>‚ü®C‚ü©</code> are given an attribute
<code>length</code>.</li>
<li>To each production with <code>‚ü®A‚ü©</code>, <code>‚ü®B‚ü©</code> or <code>‚ü®C‚ü©</code> on the left side, we attach
a rule to compute the <code>length</code>.</li>
<li>The production <code>‚ü®S‚ü© ‚à∑= ‚ü®A‚ü© ‚ü®B‚ü© ‚ü®C‚ü©</code> enforces the condition with a predicate.</li>

</ul>

</section>
<section id="slide-org82376d1-split">

<h3><span class="section-number-3">5.7</span> An example attribute grammar</h3>

<div class="org-src-container">

<pre  class="src src-text"><code trim><span style="color: #00cd68;">&#10216;</span>S<span style="color: #00cd68;">&#10217;</span> &#8759;= <span style="color: #00cd68;">&#10216;</span>A<span style="color: #00cd68;">&#10217;</span> <span style="color: #00cd68;">&#10216;</span>B<span style="color: #00cd68;">&#10217;</span> <span style="color: #00cd68;">&#10216;</span>C<span style="color: #00cd68;">&#10217;</span>
Predicate: <span style="color: #00cd68;">&#10216;</span>A<span style="color: #00cd68;">&#10217;</span>.length = <span style="color: #00cd68;">&#10216;</span>B<span style="color: #00cd68;">&#10217;</span>.length = <span style="color: #00cd68;">&#10216;</span>C<span style="color: #00cd68;">&#10217;</span>.length

<span style="color: #00cd68;">&#10216;</span>A<span style="color: #00cd68;">&#10217;</span> &#8759;= &#949;
Rule: <span style="color: #00cd68;">&#10216;</span>A<span style="color: #00cd68;">&#10217;</span>.length &#8788; 0

<span style="color: #00cd68;">&#10216;</span>A<span style="color: #00cd68;">&#10217;</span>&#8321; &#8759;= a <span style="color: #00cd68;">&#10216;</span>A<span style="color: #00cd68;">&#10217;</span>&#8322;
Rule: <span style="color: #00cd68;">&#10216;</span>A<span style="color: #00cd68;">&#10217;</span>&#8321;.length &#8788; <span style="color: #00cd68;">&#10216;</span>A<span style="color: #00cd68;">&#10217;</span>&#8322;.length + 1

<span style="color: #00cd68;">&#10216;</span>B<span style="color: #00cd68;">&#10217;</span> &#8759;= &#949;
Rule: <span style="color: #00cd68;">&#10216;</span>B<span style="color: #00cd68;">&#10217;</span>.length &#8788; 0

<span style="color: #00cd68;">&#10216;</span>B<span style="color: #00cd68;">&#10217;</span>&#8321; &#8759;= b <span style="color: #00cd68;">&#10216;</span>B<span style="color: #00cd68;">&#10217;</span>&#8322;
Rule: <span style="color: #00cd68;">&#10216;</span>B<span style="color: #00cd68;">&#10217;</span>&#8321;.length &#8788; <span style="color: #00cd68;">&#10216;</span>B<span style="color: #00cd68;">&#10217;</span>&#8322;.length + 1

<span style="color: #00cd68;">&#10216;</span>C<span style="color: #00cd68;">&#10217;</span> &#8759;= &#949;
Rule: <span style="color: #00cd68;">&#10216;</span>C<span style="color: #00cd68;">&#10217;</span>.length &#8788; 0

<span style="color: #00cd68;">&#10216;</span>C<span style="color: #00cd68;">&#10217;</span>&#8321; &#8759;= c <span style="color: #00cd68;">&#10216;</span>C<span style="color: #00cd68;">&#10217;</span>&#8322;
Rule: <span style="color: #00cd68;">&#10216;</span>C<span style="color: #00cd68;">&#10217;</span>&#8321;.length &#8788; <span style="color: #00cd68;">&#10216;</span>C<span style="color: #00cd68;">&#10217;</span>&#8322;.length + 1
</code></pre>
</div>

<p>
In productions with multiple occurrences of the same non-terminal,
we number the occurrences so we can easily refer to them
in the rules/predicates.
</p>

</section>
</section>
<section>
<section id="slide-org5780863">
<h2 id="org5780863"><span class="section-number-2">6</span> Abstract and concrete syntax; ignoring ambiguity</h2>
</section>
</section>
<section>
<section id="slide-org41a8b19">
<h2 id="org41a8b19"><span class="section-number-2">7</span> The <i>semantics</i> of formal languages</h2>
<p>
The <i>semantics</i> of a language assigns a meaning to each sentence.
</p>
<ul>
<li>In order to define a semantics, we must
have in mind a <i>semantic domain</i>;
<ul>
<li>a domain of meanings into which we map sentences.</li>

</ul></li>
<li>For instance, if we are defining a language
of natural numbers <i>Nat</i>, we will map sentences into the set <code>‚Ñï</code>.</li>
<li>Or map elements of a languages of propositions into <code>ùîπ</code>.</li>
<li>We may often provide several different definitions of
a particular mapping, to emphasise different details.</li>

</ul>

<p>
We may also have several semantic domains for a given language.
</p>
<ul>
<li>In the case of programming languages,
several domains of meaning have been proposed and used;
the three most well known are
<ul>
<li>computing devices, whether a real-world machine or an <i>abstract</i> machine,
<ul>
<li>this is known as <i>operational semantics</i></li>

</ul></li>
<li>(mathematical) functions,
<ul>
<li>this is known as <i>denotational semantics</i></li>

</ul></li>
<li>precondition/postcondition pairs
<ul>
<li>this is known as <i>axiomatic semantics</i></li>

</ul></li>

</ul></li>

</ul>

</section>
<section id="slide-org218058f">
<h3 id="org218058f"><span class="section-number-3">7.1</span> Example ‚Äì semantics of a language of natural numbers</h3>
<p>
Consider again a language of terms intended to represent
natural numbers.
</p>
<div class="org-src-container">

<pre  class="src src-text"><code trim><span style="color: #00cd68;">&#10216;</span>nat<span style="color: #00cd68;">&#10217;</span> &#8759;= "zero" | "suc" <span style="color: #00cd68;">&#10216;</span>nat<span style="color: #00cd68;">&#10217;</span> 
</code></pre>
</div>

<p>
To assign meaning to these terms,
we introduce a mapping from these (concrete) terms
to (abstract) numerals.
</p>
<div class="org-src-container">

<pre  class="src src-text"><code trim>eval zero = 0
eval <span style="color: #00cd68;">(</span>suc n<span style="color: #00cd68;">)</span> = <span style="color: #00cd68;">(</span>eval n<span style="color: #00cd68;">)</span> + 1
</code></pre>
</div>

<p>
The evaluation function in this case is very obvious and trivial,
because with this language is simply a concrete representation
of the semantic domain.
</p>
<ul>
<li>In comparison, when defining the semantics of programming languages,
the language and the semantic domain are not so directly related.</li>

</ul>

</section>
<section id="slide-org01a3036">
<h3 id="org01a3036"><span class="section-number-3">7.2</span> Example ‚Äì semantics of propositional logic</h3>
<p>
As a more complex example, we can map propositional logic terms
into the set of booleans.
</p>
<div class="org-src-container">

<pre  class="src src-text"><code trim><span style="color: #00cd68;">&#10216;</span>prop<span style="color: #00cd68;">&#10217;</span> &#8759;= "tt" | "ff" | &#172; <span style="color: #00cd68;">&#10216;</span>prop<span style="color: #00cd68;">&#10217;</span> | <span style="color: #00cd68;">&#10216;</span>prop<span style="color: #00cd68;">&#10217;</span> <span style="color: #00cd68;">(</span>&#8743; | &#8744; | &#8658; | &#8660;<span style="color: #00cd68;">)</span> <span style="color: #00cd68;">&#10216;</span>prop<span style="color: #00cd68;">&#10217;</span>
</code></pre>
</div>

<p>
In order to make the mapping less trivial, let us define it
without using boolean combinators; only constants
and ‚Äúif-then-else‚Äù statements.
</p>
<div class="org-src-container">

<pre  class="src src-text"><code trim>eval tt = true
eval ff = false

eval <span style="color: #00cd68;">(</span>&#172; p<span style="color: #00cd68;">)</span> = true    if eval p
             false   otherwise

eval <span style="color: #00cd68;">(</span>p &#8743; q<span style="color: #00cd68;">)</span> = eval q   if eval p
               false    otherwise

&#8230;
</code></pre>
</div>
<p>
Exercise: Complete this evaluation function.
</p>

</section>
<section id="slide-org1aebbfa">
<h3 id="org1aebbfa"><span class="section-number-3">7.3</span> Example ‚Äì small-step semantics of propositional logic</h3>
<p>
The evaluation function defined above can be considered
to be a <i>big-step</i> semantics.
</p>
<ul>
<li>It is a (single-valued) relation between terms and
their (final) value.</li>

</ul>

<p>
In contrast, we may define a <i>small-step</i> semantics
</p>
<ul>
<li>which maps terms to terms which are ‚Äúone step‚Äù simpler.</li>
<li>Then, once we have reduced to a constant term, that may be mapped
to a value (this part is not shown here).</li>

</ul>
<div class="org-src-container">

<pre  class="src src-text"><code trim>reduce <span style="color: #00cd68;">(</span>&#172; tt<span style="color: #00cd68;">)</span> = ff
reduce <span style="color: #00cd68;">(</span>&#172; ff<span style="color: #00cd68;">)</span> = tt
reduce <span style="color: #00cd68;">(</span>&#172; p<span style="color: #00cd68;">)</span>  = &#172; <span style="color: #00cd68;">(</span>reduce p<span style="color: #00cd68;">)</span>

reduce <span style="color: #00cd68;">(</span>tt &#8743; q<span style="color: #00cd68;">)</span> = reduce q
reduce <span style="color: #00cd68;">(</span>ff &#8743; q<span style="color: #00cd68;">)</span> = ff
reduce <span style="color: #00cd68;">(</span>p &#8743; q<span style="color: #00cd68;">)</span>  = <span style="color: #00cd68;">(</span>reduce p<span style="color: #00cd68;">)</span> &#8743; q

&#8230;
</code></pre>
</div>
<p>
Exercise: Complete this reduction function.
</p>
</section>
</section>
</div>
</div>
<script src="./reveal.js/dist/reveal.js"></script>
<script src="./reveal.js/plugin/markdown/markdown.js"></script>
<script src="./reveal.js/plugin/zoom/zoom.js"></script>
<script src="./reveal.js/plugin/notes/notes.js"></script>


<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
plugins: [RevealMarkdown,RevealZoom,RevealNotes],
width:1600, height:900, controlsLayout:'edges',
margin: 0.1, minScale:0.125, maxScale:5,
mouseWheel: true,
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
]
});
</script>
</body>
</html>
