<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-10-07 Wed 03:30 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Infinite data in Scala</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Mark Armstrong" />
<meta name="description" content="We discuss the notion of “infinite data”, and show
how we can represent such data in Scala."
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/readtheorg.css"/>
<script type="text/javascript" src="styles/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="styles/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="styles/readtheorg/js/readtheorg.js"></script>
<style>pre.src{background:#000000;color:white;} </style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Infinite data in Scala</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#Introduction">1. Introduction</a></li>
<li><a href="#Motivation">2. Motivation</a></li>
<li><a href="#Call-by-value-and-call-by-name">3. Call by value and call by name</a></li>
<li><a href="#Parameter-passing-in-Scala">4. Parameter passing in Scala</a></li>
<li><a href="#What's-the-point?">5. What's the point?</a></li>
<li><a href="#Infinite-data!">6. Infinite data!</a>
<ul>
<li><a href="#Not-with-lists…">6.1. Not with lists…</a></li>
<li><a href="#…instead,-with-lazy-lists-or-streams!">6.2. …instead, with lazy lists or streams!</a></li>
</ul>
</li>
<li><a href="#Implementing-our-own-infinite-datatypes">7. <del>(Not)</del> Implementing our own infinite datatypes</a>
<ul>
<li><a href="#The-approach">7.1. The approach</a></li>
<li><a href="#Dealing-with-the-tail-function">7.2. Dealing with the tail function</a></li>
<li><a href="#~case-object~?">7.3. <code>case object</code>?</a></li>
<li><a href="#Defining-some-methods-on-our-streams">7.4. Defining some methods on our streams</a></li>
<li><a href="#Take-care:-*make-arguments-of-type-~Stream~-by-name-arguments*">7.5. Take care: <b>make arguments of type <code>Stream</code> by name arguments</b></a></li>
<li><a href="#More-methods-on-our-streams">7.6. More methods on our streams</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-Introduction" class="outline-2">
<h2 id="Introduction"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-Introduction">
<p>
These notes were created for, and in some parts <b>during</b>,
the lecture on October 2nd and the following tutorials.
</p>
</div>
</div>

<div id="outline-container-Motivation" class="outline-2">
<h2 id="Motivation"><span class="section-number-2">2</span> Motivation</h2>
<div class="outline-text-2" id="text-Motivation">
<p>
In our current lectures, we have been discussing the λ-calculus,
and as of the time of writing this, we are about to discuss
reduction strategies.
</p>

<p>
The reduction strategies used in the λ-calculus
correspond to the parameter-passing methods
used in conventional programming languages.
</p>
</div>
</div>

<div id="outline-container-Call-by-value-and-call-by-name" class="outline-2">
<h2 id="Call-by-value-and-call-by-name"><span class="section-number-2">3</span> Call by value and call by name</h2>
<div class="outline-text-2" id="text-Call-by-value-and-call-by-name">
<p>
Today, we are interested in the
“call by value” and “call by name”
reduction strategies/parameter-passing methods.
</p>
<ul class="org-ul">
<li>Under “call by value” semantics,
a function application is only evaluated after
its arguments have been reduced to values.</li>
<li>Under “call by name” (or “call by need”) semantics,
no arguments in a function application are evaluated before
the function is applied.
<ul class="org-ul">
<li>(And no reduction is allowed inside abstractions.)</li>
</ul></li>
</ul>

<p>
(Under both schemes, the leftmost, outermost valid reduction is done first.)
</p>

<p>
We can see the difference by considering a sample redex
in the λ-calculus.
</p>
<div class="org-src-container">
<pre class="src src-text"><span style="color: #00cd68;">(</span>&#955; x &#8594; x x<span style="color: #00cd68;">)(</span><span style="color: #b6a0ff;">(</span>&#955; y &#8594; y<span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">(</span>&#955; z &#8594; z<span style="color: #b6a0ff;">)</span><span style="color: #00cd68;">)</span>
</pre>
</div>
<p>
Notice that there are two possible applications to carry out;
applying <code>λ z → z</code> to <code>λ y → y</code>, or
applying <code>(λ y → y) (λ z → z)</code> to <code>λ x → x x</code>.
</p>

<p>
A call-by-value semantics requires that the right side be evaluated first;
“a function application is only evaluated
after its arguments have been reduced to values”.
So we cannot perform the outermost application until the term on the right
is reduced.
</p>
<div class="org-src-container">
<pre class="src src-text">  <span style="color: #00cd68;">(</span>&#955; x &#8594; x x<span style="color: #00cd68;">)(</span><span style="color: #b6a0ff;">(</span>&#955; y &#8594; y<span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">(</span>&#955; z &#8594; z<span style="color: #b6a0ff;">)</span><span style="color: #00cd68;">)</span>
&#10230; <span style="color: #00cd68;">(</span>&#955; x &#8594; x x<span style="color: #00cd68;">)(</span>&#955; z &#8594; z<span style="color: #00cd68;">)</span>
&#10230; <span style="color: #00cd68;">(</span>&#955; z &#8594; z<span style="color: #00cd68;">)</span> <span style="color: #00cd68;">(</span>&#955; z &#8594; z<span style="color: #00cd68;">)</span>
&#8594; &#955; z &#8594; z
= id
</pre>
</div>

<p>
A call-by-name semantics instead requires that the outside
application is evaluated first;
“no arguments in a function application are evaluated before
the function is applied”.
So we cannot perform the application in the term on the right
until we apply the outermost application.
</p>
<div class="org-src-container">
<pre class="src src-text">  <span style="color: #00cd68;">(</span>&#955; x &#8594; x x<span style="color: #00cd68;">)(</span><span style="color: #b6a0ff;">(</span>&#955; y &#8594; y<span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">(</span>&#955; z &#8594; z<span style="color: #b6a0ff;">)</span><span style="color: #00cd68;">)</span>
&#10230; <span style="color: #00cd68;">(</span><span style="color: #b6a0ff;">(</span>&#955; y &#8594; y<span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">(</span>&#955; z &#8594; z<span style="color: #b6a0ff;">)</span><span style="color: #00cd68;">)</span> <span style="color: #00cd68;">(</span><span style="color: #b6a0ff;">(</span>&#955; y &#8594; y<span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">(</span>&#955; z &#8594; z<span style="color: #b6a0ff;">)</span><span style="color: #00cd68;">)</span>
&#8594; <span style="color: #00cd68;">(</span>&#955; z &#8594; z<span style="color: #00cd68;">)</span> <span style="color: #00cd68;">(</span><span style="color: #b6a0ff;">(</span>&#955; y &#8594; y<span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">(</span>&#955; z &#8594; z<span style="color: #b6a0ff;">)</span><span style="color: #00cd68;">)</span>
&#8594; <span style="color: #00cd68;">(</span>&#955; y &#8594; y<span style="color: #00cd68;">)</span> <span style="color: #00cd68;">(</span>&#955; z &#8594; z<span style="color: #00cd68;">)</span>
&#8594; &#955; z &#8594; z
= id
</pre>
</div>
</div>
</div>

<div id="outline-container-Parameter-passing-in-Scala" class="outline-2">
<h2 id="Parameter-passing-in-Scala"><span class="section-number-2">4</span> Parameter passing in Scala</h2>
<div class="outline-text-2" id="text-Parameter-passing-in-Scala">
<p>
By default, Scala uses a call-by-value strategy.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">f</span><span style="color: #00cd68;">(</span>x<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">Int</span><span style="color: #00cd68;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">Unit</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00cd68;">{</span> println<span style="color: #b6a0ff;">(</span><span style="color: #79a8ff;">"Called f with argument"</span><span style="color: #b6a0ff;">)</span>; println<span style="color: #b6a0ff;">(</span>x<span style="color: #b6a0ff;">)</span> <span style="color: #00cd68;">}</span>
</pre>
</div>

<p>
You may <i>opt-in</i> to call by name using what they call “by name parameters”;
simply prepend <code>=&gt;</code> to the type.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">g</span><span style="color: #00cd68;">(</span>y<span style="color: #b6a0ff;">:</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Int</span><span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">Unit</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00cd68;">{</span> println<span style="color: #b6a0ff;">(</span><span style="color: #79a8ff;">"Called g with argument"</span><span style="color: #b6a0ff;">)</span>; println<span style="color: #b6a0ff;">(</span>y<span style="color: #b6a0ff;">)</span> <span style="color: #00cd68;">}</span>
</pre>
</div>

<p>
Let us create a value that is not immediately evaluated,
and which communicates when it is evaluated,
so we can use it as an argument to test out our above definitions.
One way to do this is by defining it as a method with no parameters.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">x</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">Int</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00cd68;">{</span> println<span style="color: #b6a0ff;">(</span><span style="color: #79a8ff;">"Evaluated x"</span><span style="color: #b6a0ff;">)</span>; <span style="color: #00bcff;">1</span> <span style="color: #00cd68;">}</span>
</pre>
</div>
<p>
:TODO: explain the term lazy
</p>

<p>
Scala also has “lazy” values, which are not evaluated until used.
:TODO: how is this different than x?
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #f78fe7;">lazy</span> <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">y</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">Int</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00cd68;">{</span> println<span style="color: #b6a0ff;">(</span><span style="color: #79a8ff;">"Evaluated y"</span><span style="color: #b6a0ff;">)</span>; <span style="color: #00bcff;">2</span> <span style="color: #00cd68;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-What's-the-point?" class="outline-2">
<h2 id="What's-the-point?"><span class="section-number-2">5</span> What's the point?</h2>
<div class="outline-text-2" id="text-What's-the-point?">
<p>
Why do we want to be allowed to use call by name semantics
and lazy values?
</p>

<p>
It may make some tasks easier conceptually;
for instance, one common use case involves a function
on the natural numbers, such as one that returns the “nth” prime.
</p>

<p>
We could certainly write such a function,
but an alternative approach is to <i>lazily</i> construct
the list of all primes by <i>filtering</i> the list of all naturals.
Since it is lazily constructed, no space is used
until we begin to look up elements in the list.
(Code courtesy of this <a href="https://stackoverflow.com/q/15594227/2041536">StackOverflow</a> post,
modified to work with <code>LazyList</code>.)
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #f78fe7;">lazy</span> <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">ps</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">LazyList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">Int</span><span style="color: #00cd68;">]</span> <span style="color: #b6a0ff;">=</span>
  <span style="color: #00bcff;">2</span> #:: <span style="color: #00bcff;">LazyList</span>.from<span style="color: #00cd68;">(</span><span style="color: #00bcff;">3</span><span style="color: #00cd68;">)</span>.filter<span style="color: #00cd68;">(</span>i <span style="color: #b6a0ff;">=&gt;</span> ps.takeWhile<span style="color: #b6a0ff;">{</span>j <span style="color: #b6a0ff;">=&gt;</span> j * j &lt;= i<span style="color: #b6a0ff;">}</span>.forall<span style="color: #b6a0ff;">{</span> k <span style="color: #b6a0ff;">=&gt;</span> i % k &gt; <span style="color: #00bcff;">0</span><span style="color: #b6a0ff;">}</span><span style="color: #00cd68;">)</span>;
</pre>
</div>

<p>
And, because lazy data is not re-evaluated,
once we have looked up elements, the already calculated portion
of the list is automatically cached for us!
This is (in some instances) an advantage over the function.
</p>

<p>
Now, we have subtlely used another concept enabled by lazy values
and call-by-name semantics in the above: an infinite list!
</p>
</div>
</div>

<div id="outline-container-Infinite-data!" class="outline-2">
<h2 id="Infinite-data!"><span class="section-number-2">6</span> Infinite data!</h2>
<div class="outline-text-2" id="text-Infinite-data!">
</div>

<div id="outline-container-Not-with-lists…" class="outline-3">
<h3 id="Not-with-lists…"><span class="section-number-3">6.1</span> Not with lists…</h3>
<div class="outline-text-3" id="text-Not-with-lists…">
<p>
When we discuss lists in computer science,
they are usually defined as having <i>finite</i> length.
</p>

<p>
Let us try to break away from that convention.
We can define an infinite list by using recursion.
But what does you intuition tell you will happen here?
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #f78fe7;">lazy</span> <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">ones</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">List</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">Int</span><span style="color: #00cd68;">]</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">1</span> :: ones
</pre>
</div>
</div>
</div>

<div id="outline-container-…instead,-with-lazy-lists-or-streams!" class="outline-3">
<h3 id="…instead,-with-lazy-lists-or-streams!"><span class="section-number-3">6.2</span> …instead, with lazy lists or streams!</h3>
<div class="outline-text-3" id="text-…instead,-with-lazy-lists-or-streams!">
<p>
The <a href="https://www.scala-lang.org/api/current/scala/collection/immutable/LazyList.html">lazy list</a> type and
the <a href="https://www.scala-lang.org/api/current/scala/collection/immutable/Stream.html">stream</a> type (now deprecated in favour of lazy lists)
actually allow us to define such lists.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #f78fe7;">lazy</span> <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">ones</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">LazyList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">Int</span><span style="color: #00cd68;">]</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">1</span> #:: ones
</pre>
</div>

<p>
We can then make these lists more interesting
by filtering, zipping, etc.;
or by writing more interesting recursive definitions.
</p>
</div>
</div>
</div>

<div id="outline-container-Implementing-our-own-infinite-datatypes" class="outline-2">
<h2 id="Implementing-our-own-infinite-datatypes"><span class="section-number-2">7</span> <del>(Not)</del> Implementing our own infinite datatypes</h2>
<div class="outline-text-2" id="text-Implementing-our-own-infinite-datatypes">
</div>

<div id="outline-container-The-approach" class="outline-3">
<h3 id="The-approach"><span class="section-number-3">7.1</span> The approach</h3>
<div class="outline-text-3" id="text-The-approach">
<p>
To implement such a type <code>T</code> with the algebraic datatype approach
we have been using, we may use (recursive) parameters
of the form <code>Unit =&gt; T</code>; that is,
the type of <i>functions</i> from <code>Unit</code> to <code>T</code>.
(Recall that <code>Unit</code> is the type with just one value,
written <code>()</code> in Scala.)
</p>

<p>
Function parameters are <i>never</i> evaluated until
the function is invoked (called.)
<b>This will approach will work in any language with
higher-order functions.</b>
</p>

<p>
For example, we can define our own variant of streams.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #f78fe7;">sealed</span> <span style="color: #b6a0ff;">trait</span> <span style="color: #f78fe7;">Stream</span><span style="color: #00cd68;">[</span>+<span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span> <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Stream is covariant (marked by the +)</span>
<span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">object</span> <span style="color: #00bcff;">SNil</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #f78fe7;">Stream</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">Nothing</span><span style="color: #00cd68;">]</span> <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">The singleton Nil object</span>
<span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">class</span> <span style="color: #f78fe7;">Cons</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>a<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">A</span>, f<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">Unit</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Stream</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span><span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #f78fe7;">Stream</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-Dealing-with-the-tail-function" class="outline-3">
<h3 id="Dealing-with-the-tail-function"><span class="section-number-3">7.2</span> Dealing with the tail function</h3>
<div class="outline-text-3" id="text-Dealing-with-the-tail-function">
<p>
Given a stream of the form <code>Cons(a,f)</code>,
the <code>f</code> parameter does not directly give us the “tail” stream;
we must invoke it, writing <code>f()</code>, to obtain the tail.
</p>

<p>
In the other direction,
in order to construct a stream of the form <code>Cons(a,f)</code>,
we must “wrap” the tail stream in a function definition.
Rather than writing out a <code>def</code> and giving this function a name
(which in Scala lingo would make it a method),
we can use an <i>anonymous</i> definition,
such as below.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">ones</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">Stream</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">Int</span><span style="color: #00cd68;">]</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Cons</span><span style="color: #00cd68;">(</span><span style="color: #00bcff;">1</span>, <span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> ones<span style="color: #00cd68;">)</span>
</pre>
</div>
<p>
The <code>_ =&gt; ones</code> indicates a function of one argument;
the <code>_</code> is used in place of a variable name,
since we are not using the variable
(because it is of type <code>Unit</code>, there is really no use in
giving it a name; it must be <code>()</code>.)
</p>

<div class="org-center">
<p>
So, to construct a stream, we must “wrap” the tail;
this is also called <b>delaying</b> the tail.
</p>

<p>
To deconstruct (stream) a stream, we must “invoke” the tail;
this is also called <b>forcing</b> the tail.
</p>

<p>
<b>The concepts of delaying and forcing data are generally applicable;</b>
<b>we may later even consider a type which is just (potentially)</b>
<b>delayed data.</b>
</p>
</div>
</div>
</div>

<div id="outline-container-~case-object~?" class="outline-3">
<h3 id="~case-object~?"><span class="section-number-3">7.3</span> <code>case object</code>?</h3>
<div class="outline-text-3" id="text-~case-object~?">
<p>
We adopt here and now the convention of making our base case
a <code>case object</code>, rather than a <code>case class</code>.
The difference is that there is exactly one instance of
a <code>case object</code> (it is a singleton),
whereas there can be many of a <code>case class</code>.
Since there can only be one instance of <code>SNil</code>,
this instance needs to be a member of <code>Stream[A]</code> for any <code>A</code>,
so it must be a member of <code>Stream[Nothing]</code>, since <code>Nothing</code> is
the only subtype of all types.
This does require us to mark <code>Stream</code> as <i>covariant</i>,
meaning that <code>Stream[A]</code> is a subtype of <code>Stream[B]</code> if
<code>A</code> is a subtype of <code>B</code>.
(We will discuss subtyping, variance and covariance
in more detail later in the course.)
</p>
</div>
</div>

<div id="outline-container-Defining-some-methods-on-our-streams" class="outline-3">
<h3 id="Defining-some-methods-on-our-streams"><span class="section-number-3">7.4</span> Defining some methods on our streams</h3>
<div class="outline-text-3" id="text-Defining-some-methods-on-our-streams">
<p>
We need some methods to allow us to do
even basic tasks with our new Stream type.
</p>

<p>
For instance, we need some convenient ways
to define streams.
For instance, we can construct constant streams
that just repeat the same value.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">constantStream</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>a<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">A</span><span style="color: #00cd68;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">Stream</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span> <span style="color: #b6a0ff;">=</span>
  <span style="color: #00bcff;">Cons</span><span style="color: #00cd68;">(</span>a, <span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> constantStream<span style="color: #b6a0ff;">(</span>a<span style="color: #b6a0ff;">)</span><span style="color: #00cd68;">)</span>
</pre>
</div>

<p>
But it's relatively hard to work with streams
when we can only see the first value
when they are printed.
So, we pause giving ways to construct streams
in order to give a way to <i>deconstruct</i> them.
This method converts the first number of elements
into a list which can be nicely and easily displayed.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">take</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>n<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">Int</span>, s<span style="color: #b6a0ff;">:</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Stream</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span><span style="color: #00cd68;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">List</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span> <span style="color: #b6a0ff;">=</span> s <span style="color: #b6a0ff;">match</span> <span style="color: #00cd68;">{</span>
  <span style="color: #b6a0ff;">case</span> <span style="color: #00bcff;">SNil</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Nil</span>
  <span style="color: #b6a0ff;">case</span> <span style="color: #f78fe7;">Cons</span><span style="color: #b6a0ff;">(</span><span style="color: #00d3d0;">a</span>,<span style="color: #00d3d0;">f</span><span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">=&gt;</span> n <span style="color: #b6a0ff;">match</span> <span style="color: #b6a0ff;">{</span>
    <span style="color: #b6a0ff;">case</span> <span style="color: #00d3d0;">n</span> <span style="color: #b6a0ff;">if</span> n &gt; <span style="color: #00bcff;">0</span> <span style="color: #b6a0ff;">=&gt;</span> a :: take<span style="color: #6ae4b9;">(</span>n-1,f<span style="color: #f0ce43;">()</span><span style="color: #6ae4b9;">)</span>
    <span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Nil</span>
    <span style="color: #b6a0ff;">}</span>
  <span style="color: #00cd68;">}</span>
</pre>
</div>

<p>
Now, let's define a method that will make it easier
to define some other ways of constructing streams:
prepending a finite number of elements from a list
to a stream.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">prepend</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>l<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">List</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span>, s<span style="color: #b6a0ff;">:</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Stream</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span><span style="color: #00cd68;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">Stream</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span> <span style="color: #b6a0ff;">=</span> l <span style="color: #b6a0ff;">match</span> <span style="color: #00cd68;">{</span>
    <span style="color: #b6a0ff;">case</span> <span style="color: #00bcff;">Nil</span> <span style="color: #b6a0ff;">=&gt;</span> s
    <span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">(</span><span style="color: #00d3d0;">h</span> <span style="color: #f78fe7;">::</span> <span style="color: #00d3d0;">t</span><span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Cons</span><span style="color: #b6a0ff;">(</span>h, <span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> prepend<span style="color: #6ae4b9;">(</span>t, s<span style="color: #6ae4b9;">)</span><span style="color: #b6a0ff;">)</span>
  <span style="color: #00cd68;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-Take-care:-*make-arguments-of-type-~Stream~-by-name-arguments*" class="outline-3">
<h3 id="Take-care:-*make-arguments-of-type-~Stream~-by-name-arguments*"><span class="section-number-3">7.5</span> Take care: <b>make arguments of type <code>Stream</code> by name arguments</b></h3>
<div class="outline-text-3" id="text-Take-care:-*make-arguments-of-type-~Stream~-by-name-arguments*">
<p>
Notice that in the definition of <code>prepend</code>,
which is our first method to take a stream as an argument,
we marked the stream as a “by name” argument,
making it lazily evaluated.
</p>

<p>
This is because if we try to
use <code>prepend</code> to define a stream <i>recursively</i>,
so the recursive call is inserted as an argument
to <code>prepend</code> (e.g., <code>val ones: Stream[Int] = repeat(List(1), ones)</code>),
if that argument were <i>not</i> by name, it would be evaluated,
and we would get a stack overflow due to unbounded recursion
(this occurred during the lecture on Monday, October 5th.)
</p>

<div class="org-center">
<p>
<b>In general, mark your arguments of type <code>Stream</code> by name,</b>
<b>in order to avoid accidental evaluation.</b>
</p>
</div>
</div>
</div>

<div id="outline-container-More-methods-on-our-streams" class="outline-3">
<h3 id="More-methods-on-our-streams"><span class="section-number-3">7.6</span> More methods on our streams</h3>
<div class="outline-text-3" id="text-More-methods-on-our-streams">
<p>
Using <code>prepend</code>, let us define two ways
to go from a stream to a list;
either just convert the list to a finite stream
(one that actually does end with <code>SNil</code> eventually),
or “repeat” the list infinitely.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">toStream</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>l<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">List</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span><span style="color: #00cd68;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">Stream</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span> <span style="color: #b6a0ff;">=</span> prepend<span style="color: #00cd68;">(</span>l, <span style="color: #00bcff;">SNil</span><span style="color: #00cd68;">)</span>

<span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">repeat</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>l<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">List</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span><span style="color: #00cd68;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">Stream</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span> <span style="color: #b6a0ff;">=</span> prepend<span style="color: #00cd68;">(</span>l, repeat<span style="color: #b6a0ff;">(</span>l<span style="color: #b6a0ff;">)</span><span style="color: #00cd68;">)</span>
</pre>
</div>

<p>
We can also <i>append</i> a list to a stream, or more appropriately,
append one stream to another.
You might ask here though,
“what happens if the stream is infinite”?
The answer: nothing! The append will just never take place,
since we never reach the <code>SNil</code> case while moving
though the first stream.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">append</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>s<span style="color: #b6a0ff;">:</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Stream</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span>, t<span style="color: #b6a0ff;">:</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Stream</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span><span style="color: #00cd68;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">Stream</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span> <span style="color: #b6a0ff;">=</span> s <span style="color: #b6a0ff;">match</span> <span style="color: #00cd68;">{</span>
    <span style="color: #b6a0ff;">case</span> <span style="color: #00bcff;">SNil</span> <span style="color: #b6a0ff;">=&gt;</span> t
    <span style="color: #b6a0ff;">case</span> <span style="color: #f78fe7;">Cons</span><span style="color: #b6a0ff;">(</span><span style="color: #00d3d0;">a</span>, <span style="color: #00d3d0;">f</span><span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Cons</span><span style="color: #b6a0ff;">(</span>a, <span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> append<span style="color: #6ae4b9;">(</span>f<span style="color: #f0ce43;">()</span>,t<span style="color: #6ae4b9;">)</span><span style="color: #b6a0ff;">)</span>
  <span style="color: #00cd68;">}</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Mark Armstrong</p>
     <p class="author">Contact: <a href="mailto:markparmstrong@gmail.com">markparmstrong@gmail.com</a></p>
     <p class="date">Original date: </p>
     <p class="date">Last updated: 2020-10-07 Wed 03:29</p>
     <p class="creator">Created using <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.0.90 (<a href="https://orgmode.org">Org</a> mode 9.4)</p>
     <p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
