<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-09-24 Thu 23:11 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Boom hierarchy in Scala</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Mark Armstrong" />
<meta name="description" content="A brief background on the Boom hierarchy family of datatypes,
followed by a (in the end, flawed) implementation in Scala."
 />
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/readtheorg.css"/>
<script type="text/javascript" src="styles/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="styles/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="styles/readtheorg/js/readtheorg.js"></script>
<style>pre.src{background:#000000;color:white;} </style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">The Boom hierarchy in Scala</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#Introduction">1. Introduction</a></li>
<li><a href="#Motivation">2. Motivation</a>
<ul>
<li><a href="#Scala-as-an-object-oriented-language">2.1. Scala as an object-oriented language</a></li>
<li><a href="#Scala-as-a-functional-language">2.2. Scala as a functional language</a>
<ul>
<li><a href="#Aside:-Downside-to-immutability">2.2.1. Aside: Downside to immutability</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#The-(extended)-Boom-hierarchy">3. The (extended) Boom hierarchy&#xa0;&#xa0;&#xa0;<span class="tag"><span class="theory">theory</span></span></a>
<ul>
<li><a href="#Introduction">3.1. Introduction</a></li>
<li><a href="#Extending-the-Boom-hierarchy">3.2. Extending the Boom hierarchy</a></li>
<li><a href="#Visualising-the-Boom-hierarchy">3.3. Visualising the Boom hierarchy</a></li>
</ul>
</li>
<li><a href="#The-Boom-hierarchy-in-Scala">4. The Boom hierarchy in Scala&#xa0;&#xa0;&#xa0;<span class="tag"><span class="application">application</span></span></a>
<ul>
<li><a href="#The-AppendList-type">4.1. The <code>AppendList</code> type</a></li>
<li><a href="#Attempt-1-at-defining-cases-of-lists:-basic-classes">4.2. Attempt 1 at defining cases of lists: basic classes</a>
<ul>
<li><a href="#Aside:-Notions-of-equality">4.2.1. Aside: Notions of equality</a></li>
</ul>
</li>
<li><a href="#Attempt-2-at-defining-cases-of-lists:-case-classes">4.3. Attempt 2 at defining cases of lists: case classes</a></li>
<li><a href="#The-inherent-problem-with-~AppendList~">4.4. The inherent problem with <code>AppendList</code></a></li>
</ul>
</li>
<li><a href="#A-proper-implementation-of-lists-in-Scala.">5. A proper implementation of lists in Scala.</a></li>
<li><a href="#Reset-the-REPL!">6. Reset the REPL!</a></li>
</ul>
</div>
</div>

<div id="outline-container-org531f7ad" class="outline-2">
<h2 id="Introduction"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-Introduction">
<p>
These notes were created for, and in some parts <b>during</b>,
the lecture on September 14th and the following tutorials.
</p>
</div>
</div>

<div id="outline-container-orgae3794f" class="outline-2">
<h2 id="Motivation"><span class="section-number-2">2</span> Motivation</h2>
<div class="outline-text-2" id="text-Motivation">
</div>

<div id="outline-container-org029f835" class="outline-3">
<h3 id="Scala-as-an-object-oriented-language"><span class="section-number-3">2.1</span> Scala as an object-oriented language</h3>
<div class="outline-text-3" id="text-Scala-as-an-object-oriented-language">
<p>
Scala is a purely-object oriented language,
meaning that every value is an object (contrast this
with languages such as Java where some values
are “basic” and not objects).
</p>

<p>
Scala interops with Java, meaning that Java libraries can be used
in Scala code. It also supports many Java abstractions/constructs,
so it can be a (fairly) comfortable transition for Java programmers.
</p>

<p>
For instance, if we want to define a linked list type in Scala,
we can take an approach similar to what we might do in Java.
(This is a very naive definition and usage,
but it serves to prove the point.)
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Type annotations come after names, and are separated by a `:`.</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">The `var` keyword indicates a variable.</span>
<span style="color: #b6a0ff;">class</span> <span style="color: #f78fe7;">LinkedList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span><span style="color: #b6a0ff;">var</span> <span style="color: #dbbe5f;">hd</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">A</span>, <span style="color: #b6a0ff;">var</span> <span style="color: #dbbe5f;">tl</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">LinkedList</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span><span style="color: #00cd68;">)</span> <span style="color: #00cd68;">{</span>

  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Methods/functions are type annotated like values.</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Scala uses an `=` in method/function declarations.</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">to emphasise that they should return a value.</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">head</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">A</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">{</span>
    hd   <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">No semicolons necessary; a newline will do.</span>
  <span style="color: #b6a0ff;">}</span>

  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">No braces are needed if the right side's a single expression.</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">tail</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">LinkedList</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span> <span style="color: #b6a0ff;">=</span> tl
<span style="color: #00cd68;">}</span>

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">`val`'s are constant, unlike `var`'s.</span>
<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">l1</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">LinkedList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">Int</span><span style="color: #00cd68;">]</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #f78fe7;">LinkedList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">Int</span><span style="color: #00cd68;">](</span><span style="color: #00bcff;">1</span>, <span style="color: #00bcff;">null</span><span style="color: #00cd68;">)</span>

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">There's no need to specify a type if Scala can infer it.</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Here it can see that the type parameter `A` is `Int` on the right.</span>
<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">l2</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">LinkedList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">Int</span><span style="color: #00cd68;">]</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #f78fe7;">LinkedList</span><span style="color: #00cd68;">(</span><span style="color: #00bcff;">2</span>, l1<span style="color: #00cd68;">)</span>

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">In fact, it can tell the type of the `val` too.</span>
<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">l3</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #f78fe7;">LinkedList</span><span style="color: #00cd68;">(</span><span style="color: #00bcff;">3</span>, l2<span style="color: #00cd68;">)</span>


<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Let's define a value as a quick sanity test.</span>
<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">test1</span> <span style="color: #b6a0ff;">=</span> l1.head == <span style="color: #00bcff;">1</span>
</pre>
</div>

<p>
But this is only one part of Scala,
and for our purposes it's the less interesting part.
(We could just use Java for this much.)
</p>
</div>
</div>

<div id="outline-container-org460fa2a" class="outline-3">
<h3 id="Scala-as-a-functional-language"><span class="section-number-3">2.2</span> Scala as a functional language</h3>
<div class="outline-text-3" id="text-Scala-as-a-functional-language">
<p>
We are interested in Scala primarily because it supports
functional abstractions.
</p>

<p>
The distinguishing abstractions of
functional programming languages are:
</p>
<ol class="org-ol">
<li>Functions are values, i.e., data.
<ul class="org-ul">
<li>This is referred to by the term “first-class functions”,
implying that functions are not excluded
from being treated as data.</li>
<li>This allows for <i>higher-order</i> functions;
functions which take other functions as argument.</li>
</ul></li>
<li>All values (data) are <i>immutable</i>.
<ul class="org-ul">
<li>(At least in “pure” functional languages.)</li>
<li>Variables still change throughout the program,
but only because they are bound to different values
at different points in the runtime.
Not because an assignment/update was carried out.
<ul class="org-ul">
<li>For instance, in a recursive call, the arguments change.</li>
</ul></li>
</ul></li>
</ol>

<p>
We will concern ourselves with (1) another time.
For today, we are considering (2).
</p>

<p>
Briefly, the advantage to immutable data is that
enables the programmer a level of certainty that is not available
if data is mutable.
</p>

<p>
Consider for a moment this pseudocode regarding
our earlier linked lists.
</p>
<pre class="example">
// This is pseudocode
val l1: LinkedList[Int] = … // Some complicated list creation

somebodyElsesFunction(l1)
</pre>
<p>
What can I say about my list <code>l1</code> after I run “somebody else's”
function on it?
</p>

<p>
Answer: not much! It could have changed in many ways,
so anything I knew about it may no longer be true.
</p>
</div>

<div id="outline-container-org7573687" class="outline-4">
<h4 id="Aside:-Downside-to-immutability"><span class="section-number-4">2.2.1</span> Aside: Downside to immutability</h4>
<div class="outline-text-4" id="text-Aside:-Downside-to-immutability">
<p>
There is a not insignificant downside to enforcing immutability
in a language/code base.
</p>

<p>
If all data is immutable, then to “make changes” to a value
(such as a list or a tree),
we must in fact make a copy of that value
with the changes we want applied.
</p>

<p>
As you can imagine, this copying is expensive,
both in terms of space and time.
</p>

<p>
<i>However</i>, well-designed languages can mitigate this
in various ways, including by having values “share”
some pieces of themselves.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org7175d52" class="outline-2">
<h2 id="The-(extended)-Boom-hierarchy"><span class="section-number-2">3</span> The (extended) Boom hierarchy&#xa0;&#xa0;&#xa0;<span class="tag"><span class="theory">theory</span></span></h2>
<div class="outline-text-2" id="text-The-(extended)-Boom-hierarchy">
<p>
We now briefly take with a (relatively brief) dive into some theory,
to give us an example type to consider in Scala.
</p>
</div>

<div id="outline-container-org6f7b501" class="outline-3">
<h3 id="Introduction"><span class="section-number-3">3.1</span> Introduction</h3>
<div class="outline-text-3" id="text-Introduction">
<p>
The Boom hierarchy was introduced
by <a href="https://www.kestrel.edu/people/meertens/publications/">Lambert Meertens</a> in
<a href="https://www.kestrel.edu/people/meertens/publications/papers/Algorithmics.pdf">Algorithmics — Towards programming as a mathematical activity</a>;
Meertens attributes the concept to H. J. Boom, hence the name.
</p>

<p>
The Boom hierachy is a family of data structures
—namely trees, lists, bags and sets—
for which we have an <code>empty</code> value and can construct <code>singleton</code> values,
and which include a <code>join</code> operation
(for sets and bags also called <code>union</code>, written <code>∪</code>,
and for lists also called <code>append</code>, <code>++</code>).
</p>

<p>
:TODO:
Notation:
</p>
<ul class="org-ul">
<li><code>[]</code> for empty,</li>
<li><code>[a]</code> for a singleton containing <code>a</code>,</li>
<li><code>++</code> for append.</li>
</ul>

<p>
The basic idea of the hierarchy is that
</p>
<ul class="org-ul">
<li>sets have a <code>join</code> operation which
<ul class="org-ul">
<li>has an identity <code>A ∪ ∅ = A</code>,</li>
<li>is idempotent <code>A ∪ A = A</code>,</li>
<li>is commutative <code>A ∪ B = B ∪ A</code>, and</li>
<li>is associative <code>A ∪ (B ∪ C) = (A ∪ B) ∪ C</code>. Then,</li>
</ul></li>
<li>bags are like sets, except the <code>join</code> operation is not idempotent,</li>
<li>lists are like bags, except the <code>join</code> operation is not commutative, and</li>
<li>trees are like lists, except the <code>join</code> operation is not associative.</li>
</ul>

<p>
The paper is interested in laws satisfied by the
higher-order functions <code>reduce</code> (often called <code>fold</code>),
<code>map</code> and <code>filter</code> over those structures.
</p>
</div>
</div>

<div id="outline-container-org11d6db6" class="outline-3">
<h3 id="Extending-the-Boom-hierarchy"><span class="section-number-3">3.2</span> Extending the Boom hierarchy</h3>
<div class="outline-text-3" id="text-Extending-the-Boom-hierarchy">
<p>
Alexander Bunkenburg's later paper
“<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.49.3252&amp;rep=rep1&amp;type=pdf">The Boom Hierarchy</a>” 
investigates this area further, by considering
what data structures can be obtained by taking different combinations
of the above listed features of the <code>join</code> operation.
The abstract of that paper reads
</p>
<blockquote>
<p>
“The Boom Hierarchy is the family of data structures tree, list, bag, set.
By combining their properties in other ways,
more data structures can be made, like mobiles.
The paper defines the data structures of this extended Boom Hierarchy
and shows how the functions reduce, map, and filter are applied to them.”
</p>
</blockquote>

<p>
For instance, through this process we arrive at
</p>
<ul class="org-ul">
<li>the <code>nonempty list</code> data structure or <code>nonempty tree</code> data structure,
which lack an identity.</li>
<li>the <code>mobile</code> data structure, which are like trees
except that they “can spin” (the branching order is arbitrary).</li>
</ul>
</div>
</div>

<div id="outline-container-orgcd5ce90" class="outline-3">
<h3 id="Visualising-the-Boom-hierarchy"><span class="section-number-3">3.3</span> Visualising the Boom hierarchy</h3>
<div class="outline-text-3" id="text-Visualising-the-Boom-hierarchy">
<p>
We can visualise the layout of some of these structures:
</p>

<div class="figure">
<p><img src="media/BOOM.png" alt="BOOM.png" />
</p>
</div>

<p>
Not all of these types are easily representable in most programming languages;
we can say they are <i>abstract</i> types instead of <i>concrete</i> types.
I've highlighted the ones which are not in the diagram using dashed lines.
</p>

<p>
Exercise: Why are those types not easily represented in standard
programming languages?
</p>

<p>
Exercise: Is it impossible for those types to be easily represented
in a programming language?
</p>
</div>
</div>
</div>

<div id="outline-container-org223abe6" class="outline-2">
<h2 id="The-Boom-hierarchy-in-Scala"><span class="section-number-2">4</span> The Boom hierarchy in Scala&#xa0;&#xa0;&#xa0;<span class="tag"><span class="application">application</span></span></h2>
<div class="outline-text-2" id="text-The-Boom-hierarchy-in-Scala">
<div class="org-center">
<p>
<b>Heads up: this section consists of failed attempts</b>
<b>and subsequent corrections. Read carefully, and double check</b>
<b>before borrowing any code. Or skip to the next section.</b>
</p>
</div>

<p>
Let us try to implement the lists discussed in the Boom hierarchy
in Scala, and make them <i>immutable</i>, for the reasons discussed in
<a href="#Scala-as-a-functional-language">Scala as a functional langauge</a>.
</p>
</div>

<div id="outline-container-orgeee400f" class="outline-3">
<h3 id="The-AppendList-type"><span class="section-number-3">4.1</span> The <code>AppendList</code> type</h3>
<div class="outline-text-3" id="text-The-AppendList-type">
<p>
Let us implement the list type as described in the Boom hierarchy paper
in Scala. We'll call these <code>AppendList</code>, as they take <code>Append</code> as
the basic operation.
</p>

<div class="org-center">
<p>
<b>Extra heads up: there's a big flaw in defining lists this way,</b>
<b>so even when we get it right we're wrong.</b>
<b>We'll discuss the problem at the end.</b>
</p>
</div>

<p>
Those lists have three cases;
</p>
<ul class="org-ul">
<li>the <code>Empty</code> list,</li>
<li>the <code>Single</code>-ton lists, and</li>
<li>the <code>Concat</code>-enation of two lists.</li>
</ul>

<p>
The Scala convention for implementing types such as this
that consist of a number of cases by first giving
a <i>super-type</i> which a <i>sub-type</i>
for each case will <i>extend</i> (extending is also called inheriting).
</p>

<p>
This super-type should not be instatiable,
because we want to restrict instatiability to the given cases.
(Recall from 2fa3: types should have <b>no junk</b> and no confusion.) 
</p>

<p>
A <code>trait</code> is similar to a <code>class</code>, except it cannot be instantiated
—meaning it cannot be constructed.
It is similar to an <code>interface</code> in Java.
(This also makes it similar to an <code>abstract class</code>,
except it's more flexible; see
<a href="https://docs.scala-lang.org/overviews/scala-book/abstract-classes.html">the Scala docs</a>.)
</p>
<pre class="example">
trait AppendList[A]
// sub-class definitions yet to come
</pre>

<p>
In fact, in the interest of not introducing “junk”,
we should use the <code>sealed</code> keyword which prevents code
from outside this block from extending <code>AppendList</code>.
</p>
<pre class="example">
sealed trait AppendList[A]
// sub-class definitions yet to come
</pre>
</div>
</div>

<div id="outline-container-org0866fbe" class="outline-3">
<h3 id="Attempt-1-at-defining-cases-of-lists:-basic-classes"><span class="section-number-3">4.2</span> Attempt 1 at defining cases of lists: basic classes</h3>
<div class="outline-text-3" id="text-Attempt-1-at-defining-cases-of-lists:-basic-classes">
<p>
Now we need to add sub-types which are instantiable.
Note that every instance (value) of one of the sub-types
is also a value of the super-type.
So even though <code>AppendList</code> cannot be instantiated,
we can create <code>AppendList</code> values.
</p>

<p>
(Yes, this means a single value can have many types;
specifically, it has a chain of types,
each one a sub-type of the next).
</p>

<p>
Exercise: where does the chain end?
</p>

<p>
We can fill in a <code>class</code> for each case.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #b6a0ff;">trait</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span>
<span style="color: #b6a0ff;">class</span> <span style="color: #f78fe7;">Empty</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]()</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span>
<span style="color: #b6a0ff;">class</span> <span style="color: #f78fe7;">Single</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>a<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">A</span><span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span>
<span style="color: #b6a0ff;">class</span> <span style="color: #f78fe7;">Concat</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>l<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span>, r<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span><span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span>
</pre>
</div>

<p>
But if we try out this definition, we may be disappointed.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">empty1</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #f78fe7;">Empty</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">Int</span><span style="color: #00cd68;">]</span>
<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">empty2</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #f78fe7;">Empty</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">Int</span><span style="color: #00cd68;">]</span>

<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">list1</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #f78fe7;">Concat</span><span style="color: #00cd68;">(</span><span style="color: #b6a0ff;">new</span> <span style="color: #f78fe7;">Single</span><span style="color: #b6a0ff;">(</span><span style="color: #00bcff;">1</span><span style="color: #b6a0ff;">)</span>, <span style="color: #b6a0ff;">new</span> <span style="color: #f78fe7;">Single</span><span style="color: #b6a0ff;">(</span><span style="color: #00bcff;">2</span><span style="color: #b6a0ff;">)</span><span style="color: #00cd68;">)</span>

empty1 == empty2  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">equality check</span>
</pre>
</div>
<p>
:TODO: why? what's so bad about the result of the equality check?
</p>

<p>
:TODO: The fact that this check failed tells me these are not the same in memory.
</p>
</div>

<div id="outline-container-orga0378bb" class="outline-4">
<h4 id="Aside:-Notions-of-equality"><span class="section-number-4">4.2.1</span> Aside: Notions of equality</h4>
<div class="outline-text-4" id="text-Aside:-Notions-of-equality">
<p>
:TODO:
</p>
</div>
</div>
</div>

<div id="outline-container-org7862e3a" class="outline-3">
<h3 id="Attempt-2-at-defining-cases-of-lists:-case-classes"><span class="section-number-3">4.3</span> Attempt 2 at defining cases of lists: case classes</h3>
<div class="outline-text-3" id="text-Attempt-2-at-defining-cases-of-lists:-case-classes">
<p>
Our <code>class</code> based definition above caused two instances
of the same list (same in the sense that their
construction was the same)
as different (unequal) lists.
</p>

<p>
The reason comes back to mutability.
A regular <code>class</code> may have mutable data (non-constant fields).
So the runtime is aware that <code>empty1</code> and <code>empty2</code> could
actually be different (even though, with just our definitions above,
there isn't a way to make them significantly different).
</p>

<p>
Since we intend to work with immutable data,
we need something more than just <code>class</code>.
</p>

<p>
Specifically, what we want is provided in
Scala by a <code>case class</code>.
A <code>case</code> class has no mutable state (no non-constant fields).
(Additionally all its fields are public).
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #f78fe7;">sealed</span> <span style="color: #b6a0ff;">trait</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span>
<span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">class</span> <span style="color: #f78fe7;">Empty</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]()</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span>
<span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">class</span> <span style="color: #f78fe7;">Single</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>a<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">A</span><span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span>
<span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">class</span> <span style="color: #f78fe7;">Concat</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>l<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span>, r<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span><span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span>
</pre>
</div>

<p>
The name <code>case class</code> is used because
we often <i>pattern match</i> (or, equivalently, <i>case split</i>)
over types defined this way.
</p>
</div>
</div>

<div id="outline-container-orgf24da54" class="outline-3">
<h3 id="The-inherent-problem-with-~AppendList~"><span class="section-number-3">4.4</span> The inherent problem with <code>AppendList</code></h3>
<div class="outline-text-3" id="text-The-inherent-problem-with-~AppendList~">
<blockquote>
<p>
“Each data structure is the
free algebra of its binary operation <code>++.</code>”
</p>
</blockquote>
<p>
This means, since <code>a ++ [] = a</code> by the identity law,
in the paper, <code>a ++ []</code> and <code>a</code> will both be the same value of <code>List</code>.
</p>

<p>
Let's try that in Scala.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #f78fe7;">sealed</span> <span style="color: #b6a0ff;">trait</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span>
<span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">class</span> <span style="color: #f78fe7;">Empty</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]()</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span>
<span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">class</span> <span style="color: #f78fe7;">Single</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>a<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">A</span><span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span>
<span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">class</span> <span style="color: #f78fe7;">Concat</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>l<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span>, r<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span><span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #f78fe7;">AppendList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span>

<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">listofone</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Single</span><span style="color: #00cd68;">(</span><span style="color: #00bcff;">1</span><span style="color: #00cd68;">)</span>
<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">anotherlistofone</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Concat</span><span style="color: #00cd68;">(</span>listofone, <span style="color: #00bcff;">Empty</span><span style="color: #b6a0ff;">()</span><span style="color: #00cd68;">)</span>

listofone == anotherlistofone
</pre>
</div>

<p>
:TODO: We have confusion!
</p>
</div>
</div>
</div>

<div id="outline-container-org9504da4" class="outline-2">
<h2 id="A-proper-implementation-of-lists-in-Scala."><span class="section-number-2">5</span> A proper implementation of lists in Scala.</h2>
<div class="outline-text-2" id="text-A-proper-implementation-of-lists-in-Scala.">
<div class="org-src-container">
<pre class="src src-elm"><span style="color: #b6a0ff;">type</span> <span style="color: #f78fe7;">List</span> a <span style="color: #f78fe7;">=</span> <span style="color: #f78fe7;">Empty</span> <span style="color: #f78fe7;">|</span> <span style="color: #f78fe7;">Cons</span> a <span style="color: #00cd68;">(</span><span style="color: #f78fe7;">List</span> a<span style="color: #00cd68;">)</span>
</pre>
</div>

<p>
Our final, correct implementation
ensures there is only one way to construct a given (abstract) list,
by using “more concrete” constructors.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #f78fe7;">sealed</span> <span style="color: #b6a0ff;">trait</span> <span style="color: #f78fe7;">ConsList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span>
<span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">class</span> <span style="color: #f78fe7;">Empty</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]()</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #f78fe7;">ConsList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span>
<span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">class</span> <span style="color: #f78fe7;">Cons</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>hd<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">A</span>, tl<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">ConsList</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span><span style="color: #00cd68;">)</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #f78fe7;">ConsList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span>
</pre>
</div>

<p>
We can try out some definitions on this type.
</p>
<div class="org-src-container">
<pre class="src src-amm"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">sum</span><span style="color: #00cd68;">(</span>xs<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">ConsList</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">Int</span><span style="color: #b6a0ff;">]</span><span style="color: #00cd68;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">Int</span> <span style="color: #b6a0ff;">=</span> xs <span style="color: #b6a0ff;">match</span> <span style="color: #00cd68;">{</span>
  <span style="color: #b6a0ff;">case</span> <span style="color: #f78fe7;">Empty</span><span style="color: #b6a0ff;">()</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">0</span>
  <span style="color: #b6a0ff;">case</span> <span style="color: #f78fe7;">Cons</span><span style="color: #b6a0ff;">(</span><span style="color: #00d3d0;">hd</span>, <span style="color: #00d3d0;">tl</span><span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">=&gt;</span> hd + sum<span style="color: #b6a0ff;">(</span>tl<span style="color: #b6a0ff;">)</span>
<span style="color: #00cd68;">}</span>

<span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">append</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">](</span>xs<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">ConsList</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span>, ys<span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">ConsList</span><span style="color: #b6a0ff;">[</span><span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">]</span><span style="color: #00cd68;">)</span><span style="color: #b6a0ff;">:</span> <span style="color: #f78fe7;">ConsList</span><span style="color: #00cd68;">[</span><span style="color: #00bcff;">A</span><span style="color: #00cd68;">]</span> <span style="color: #b6a0ff;">=</span>
  xs <span style="color: #b6a0ff;">match</span> <span style="color: #00cd68;">{</span>
    <span style="color: #b6a0ff;">case</span> <span style="color: #f78fe7;">Empty</span><span style="color: #b6a0ff;">()</span> <span style="color: #b6a0ff;">=&gt;</span> ys
    <span style="color: #b6a0ff;">case</span> <span style="color: #f78fe7;">Cons</span><span style="color: #b6a0ff;">(</span><span style="color: #00d3d0;">hd</span>, <span style="color: #00d3d0;">tl</span><span style="color: #b6a0ff;">)</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Cons</span><span style="color: #b6a0ff;">(</span>hd, append<span style="color: #6ae4b9;">(</span>tl, ys<span style="color: #6ae4b9;">)</span><span style="color: #b6a0ff;">)</span>
  <span style="color: #00cd68;">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-amm"><span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">test</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Cons</span><span style="color: #00cd68;">(</span><span style="color: #00bcff;">1</span>,<span style="color: #00bcff;">Cons</span><span style="color: #b6a0ff;">(</span><span style="color: #00bcff;">2</span>,<span style="color: #00bcff;">Cons</span><span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">3</span>,<span style="color: #00bcff;">Empty</span><span style="color: #f0ce43;">()</span><span style="color: #6ae4b9;">)</span><span style="color: #b6a0ff;">)</span><span style="color: #00cd68;">)</span>
<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">test2</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Cons</span><span style="color: #00cd68;">(</span><span style="color: #00bcff;">1</span>,<span style="color: #00bcff;">Cons</span><span style="color: #b6a0ff;">(</span><span style="color: #00bcff;">2</span>,<span style="color: #00bcff;">Cons</span><span style="color: #6ae4b9;">(</span><span style="color: #00bcff;">3</span>,<span style="color: #00bcff;">Empty</span><span style="color: #f0ce43;">()</span><span style="color: #6ae4b9;">)</span><span style="color: #b6a0ff;">)</span><span style="color: #00cd68;">)</span>

append<span style="color: #00cd68;">(</span>test,test2<span style="color: #00cd68;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org1a0c203" class="outline-2">
<h2 id="Reset-the-REPL!"><span class="section-number-2">6</span> Reset the REPL!</h2>
<div class="outline-text-2" id="text-Reset-the-REPL!">
<p>
A nice feature of the Ammonite REPL for Scala
is that you can save and load the session state,
allowing you to more safely try things out
and then restore to an earlier state if you need to.
See <a href="https://ammonite.io/#Save/LoadSession">https://ammonite.io/#Save/LoadSession</a>
</p>

<p>
To save, run
</p>
<div class="org-src-container">
<pre class="src src-amm">repl.sess.save<span style="color: #00cd68;">()</span>
</pre>
</div>

<p>
To load, run
</p>
<div class="org-src-container">
<pre class="src src-amm">repl.sess.load<span style="color: #00cd68;">()</span>
</pre>
</div>

<p>
Note you can provide strings as arguments to name the states
being saved/loaded.
</p>

<p>
If you don't use names, and need to restore an older state,
you can use <code>repl.sess.pop(n)</code> to pop <code>n</code> saved states off the session.
</p>

<p>
If you simply want to restart, just off an extreme number
of saved states.
</p>
<div class="org-src-container">
<pre class="src src-amm">repl.sess.pop<span style="color: #00cd68;">(</span><span style="color: #00bcff;">999</span><span style="color: #00cd68;">)</span>
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Mark Armstrong</p>
     <p class="author">Contact: <a href="mailto:markparmstrong@gmail.com">markparmstrong@gmail.com</a></p>
     <p class="date">Original date: </p>
     <p class="date">Last updated: 2020-09-16 Wed 10:22</p>
     <p class="creator">Created using <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.0.90 (<a href="https://orgmode.org">Org</a> mode 9.3.8)</p>
     <p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
